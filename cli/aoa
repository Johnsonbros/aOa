#!/usr/bin/env bash
# aoa - 5 angles. 1 attack.
#
# Global Installation:
#   ./install.sh            Install aOa globally to ~/.aoa/
#
# Per-Project:
#   aoa init                Enable aOa for current project
#   aoa remove              Disable aOa for current project
#   aoa projects            List all enabled projects
#
# Search (after init):
#   aoa search <term>       Search current project
#   aoa multi <t1,t2,...>   Multi-term search
#   aoa health              Check services

set -e

# Configuration
GATEWAY_HOST="${AOA_GATEWAY_HOST:-localhost}"
GATEWAY_PORT="${AOA_GATEWAY_PORT:-8080}"

# Find AOA_HOME by locating the CLI script itself
CLI_PATH="$(readlink -f "$0")"
AOA_HOME="$(dirname "$(dirname "$CLI_PATH")")"
AOA_DATA="${AOA_DATA:-$AOA_HOME/data}"

INDEX_URL="http://${GATEWAY_HOST}:${GATEWAY_PORT}"
STATUS_URL="http://${GATEWAY_HOST}:${GATEWAY_PORT}"

# Colors
BOLD='\033[1m'
DIM='\033[2m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
RED='\033[0;31m'
NC='\033[0m'

# =============================================================================
# Project Management Commands
# =============================================================================

# Get project ID from .aoa/home.json (UUID generated at init)
get_project_id() {
    local project_root=$(get_project_root)
    if [ -z "$project_root" ]; then
        echo ""
        return
    fi

    local home_file="$project_root/.aoa/home.json"
    if [ -f "$home_file" ]; then
        jq -r '.project_id // empty' "$home_file" 2>/dev/null
    fi
}

# Generate a new UUID for project identification
generate_project_id() {
    # Try uuidgen first (Linux/macOS), fall back to Python
    if command -v uuidgen > /dev/null 2>&1; then
        uuidgen | tr '[:upper:]' '[:lower:]'
    else
        python3 -c "import uuid; print(uuid.uuid4())"
    fi
}

# Get project root
get_project_root() {
    git rev-parse --show-toplevel 2>/dev/null
}

# Get project name
get_project_name() {
    local root=$(get_project_root)
    if [ -n "$root" ]; then
        basename "$root"
    fi
}

cmd_init() {
    echo -e "${CYAN}${BOLD}‚ö° aOa - Initializing Project${NC}"
    echo

    # Check if aOa is installed globally
    if [ ! -d "$AOA_HOME" ]; then
        echo -e "${RED}aOa not installed globally.${NC}"
        echo -e "${DIM}Run ./install.sh from the aOa repository first.${NC}"
        return 1
    fi

    # Check if we're in a git repo
    local project_root=$(get_project_root)
    if [ -z "$project_root" ]; then
        echo -e "${RED}Not in a git repository.${NC}"
        echo -e "${DIM}aOa requires a git repo to detect project boundaries.${NC}"
        return 1
    fi

    local project_name=$(get_project_name)

    # Check if already has a project_id, otherwise generate new one
    local existing_id=$(get_project_id)
    local project_id="${existing_id:-$(generate_project_id)}"

    echo -e "  Project: ${BOLD}${project_name}${NC}"
    echo -e "  Path:    ${DIM}${project_root}${NC}"
    echo -e "  ID:      ${DIM}${project_id}${NC}"
    echo

    # Check if already initialized
    if [ -f "$project_root/.claude/hooks/aoa-status-line.sh" ]; then
        echo -e "${YELLOW}Project already initialized.${NC}"
        echo -e "${DIM}Run 'aoa remove' first to reinitialize.${NC}"
        return 0
    fi

    # Create .claude directories
    mkdir -p "$project_root/.claude/hooks"
    mkdir -p "$project_root/.claude/skills"

    # Copy hooks from templates
    echo -n "  Installing hooks.............. "
    cp "$AOA_HOME/plugin/hooks/"*.py "$project_root/.claude/hooks/" 2>/dev/null || true
    cp "$AOA_HOME/plugin/hooks/"*.sh "$project_root/.claude/hooks/" 2>/dev/null || true
    chmod +x "$project_root/.claude/hooks/"*.py "$project_root/.claude/hooks/"*.sh 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Copy skills (directory-based structure for Claude Code)
    echo -n "  Installing skills............. "
    for skill_dir in "$AOA_HOME/plugin/skills/"*/; do
        if [ -d "$skill_dir" ]; then
            cp -r "$skill_dir" "$project_root/.claude/skills/" 2>/dev/null || true
        fi
    done
    echo -e "${GREEN}‚úì${NC}"

    # Copy agents
    echo -n "  Installing agents............. "
    mkdir -p "$project_root/.claude/agents"
    cp "$AOA_HOME/plugin/agents/"*.md "$project_root/.claude/agents/" 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Create .aoa/ folder with home pointer
    echo -n "  Creating .aoa/ config......... "
    mkdir -p "$project_root/.aoa"

    # home.json - project config with UUID identifier
    cat > "$project_root/.aoa/home.json" << EOFHOME
{
  "aoa_home": "$AOA_HOME",
  "data_dir": "$AOA_DATA",
  "project_id": "$project_id",
  "project_root": "$project_root"
}
EOFHOME

    # whitelist.txt - optional repos/URLs for this project
    if [ ! -f "$project_root/.aoa/whitelist.txt" ]; then
        cat > "$project_root/.aoa/whitelist.txt" << 'EOFWHITELIST'
# aOa Whitelist - URLs allowed for this project
# Add one domain per line (HTTPS only)
#
# Examples:
# github.com/your-org/repo
# docs.your-company.com
# internal-git.example.com
EOFWHITELIST
    fi

    # README.md - explains the folder (only if not present)
    if [ ! -f "$project_root/.aoa/README.md" ]; then
        cat > "$project_root/.aoa/README.md" << 'EOFREADME'
# .aoa - aOa Project Link

This folder links this project to your global aOa installation.

## Files

| File | Purpose |
|------|---------|
| `home.json` | Points to global aOa install location |
| `whitelist.txt` | Optional: extra URLs/repos for this project |

## What is aOa?

aOa (Angle of Attack) provides fast O(1) code search for Claude Code.
It replaces slow Grep/Glob operations with indexed symbol lookup.

## Commands

```bash
aoa search <term>    # Search this project
aoa health           # Check services
aoa remove           # Remove aOa from this project
```

## Global Settings

To change aOa settings (port, confidence threshold, etc.),
edit the config.json in your global aOa installation.
EOFREADME
    fi

    # Copy USAGE.md - goal-oriented guide for Claude
    cp "$AOA_HOME/plugin/USAGE.md" "$project_root/.aoa/USAGE.md" 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Add aOa reference to CLAUDE.md
    echo -n "  Updating CLAUDE.md............ "
    local claude_md="$project_root/CLAUDE.md"
    local aoa_marker="# aOa Integration"

    if [ -f "$claude_md" ]; then
        # Check if already has aOa section
        if ! grep -q "$aoa_marker" "$claude_md" 2>/dev/null; then
            # Append aOa reference
            cat >> "$claude_md" << 'EOFCLAUDE'

# aOa Integration

**CRITICAL: Use `aoa grep` instead of Grep/Glob. It's 10-100x faster.**

## Quickstart Triggers

When user says **"Hey aOa"**, **"Tag my code"**, or **"aOa quickstart"**:

1. Run `aoa outline --pending --json` to check pending files
2. Respond with this (DO NOT read any files first):

```
‚ö° aOa activated

Your codebase is already indexed‚Äîfast symbol search works right now.
Try it: `aoa grep [anything]`

I found [X] files that need semantic compression.
Let me tag these in the background. This is FREE‚Äîdoesn't use your tokens.

Takes about 2-3 minutes. To watch progress, open another terminal:
  aoa intent

Keep coding. I'm not blocking you.
Once done, I'll find code by meaning, not just keywords.
```

3. Launch: `Task(subagent_type="aoa-outline", prompt="Tag all pending files", run_in_background=true)`

## Commands

| Command | Use For |
|---------|---------|
| `aoa grep <term>` | Find code fast (ALWAYS use instead of Grep) |
| `aoa grep "a b c"` | Multi-term OR search |
| `aoa grep -a a,b,c` | Multi-term AND search |
| `aoa outline <file>` | See file structure without reading it all |
| `aoa intent` | Track what's being worked on |

## Rules

- ‚úÖ ALWAYS use `aoa grep` instead of Grep/Glob
- ‚úÖ Read specific line ranges from aOa results (not whole files)
- ‚ùå DO NOT use subagents for codebase exploration (hooks don't work in subagents)

## Hook Integration

aOa hooks run on every prompt and tool use. When you see these in additionalContext:

**aOa Auto-Tag Request**: Generate 3-5 semantic hashtags directly (YOU are the model), then store:
\`\`\`bash
curl -s -X POST localhost:8080/intent -H "Content-Type: application/json" -d '{"tool": "Intent", "tags": ["#your-tags"], ...}'
\`\`\`

**aOa Predicted Files**: Files predicted based on your prompt keywords. Consider these when exploring.

See \`.aoa/USAGE.md\` for full guide.
EOFCLAUDE
            echo -e "${GREEN}‚úì${NC} ${DIM}(appended)${NC}"
        else
            echo -e "${YELLOW}‚úì${NC} ${DIM}(already present)${NC}"
        fi
    else
        # Create CLAUDE.md with full aOa section
        cat > "$claude_md" << 'EOFCLAUDE'
# aOa Integration

**CRITICAL: Use `aoa grep` instead of Grep/Glob. It's 10-100x faster.**

## Quickstart Triggers

When user says **"Hey aOa"**, **"Tag my code"**, or **"aOa quickstart"**:

1. Run `aoa outline --pending --json` to check pending files
2. Respond with this (DO NOT read any files first):

```
‚ö° aOa activated

Your codebase is already indexed‚Äîfast symbol search works right now.
Try it: `aoa grep [anything]`

I found [X] files that need semantic compression.
Let me tag these in the background. This is FREE‚Äîdoesn't use your tokens.

Takes about 2-3 minutes. To watch progress, open another terminal:
  aoa intent

Keep coding. I'm not blocking you.
Once done, I'll find code by meaning, not just keywords.
```

3. Launch: `Task(subagent_type="aoa-outline", prompt="Tag all pending files", run_in_background=true)`

## Commands

| Command | Use For |
|---------|---------|
| `aoa grep <term>` | Find code fast (ALWAYS use instead of Grep) |
| `aoa grep "a b c"` | Multi-term OR search |
| `aoa grep -a a,b,c` | Multi-term AND search |
| `aoa outline <file>` | See file structure without reading it all |
| `aoa intent` | Track what's being worked on |

## Rules

- ‚úÖ ALWAYS use `aoa grep` instead of Grep/Glob
- ‚úÖ Read specific line ranges from aOa results (not whole files)
- ‚ùå DO NOT use subagents for codebase exploration (hooks don't work in subagents)

## Hook Integration

aOa hooks run on every prompt and tool use. When you see these in additionalContext:

**aOa Auto-Tag Request**: Generate 3-5 semantic hashtags directly (YOU are the model), then store:
\`\`\`bash
curl -s -X POST localhost:8080/intent -H "Content-Type: application/json" -d '{"tool": "Intent", "tags": ["#your-tags"], ...}'
\`\`\`

**aOa Predicted Files**: Files predicted based on your prompt keywords. Consider these when exploring.

See \`.aoa/USAGE.md\` for full guide.
EOFCLAUDE
        echo -e "${GREEN}‚úì${NC} ${DIM}(created)${NC}"
    fi

    # Copy or merge settings template
    echo -n "  Merging settings.............. "
    if [ ! -f "$project_root/.claude/settings.local.json" ]; then
        # No existing settings - copy template
        cp "$AOA_DATA/settings.template.json" "$project_root/.claude/settings.local.json"
        echo -e "${GREEN}‚úì${NC}"
    else
        # Backup existing settings
        cp "$project_root/.claude/settings.local.json" \
           "$project_root/.claude/settings.local.json.pre-aoa-$(date +%Y%m%d-%H%M%S)"

        # Deep merge: preserve their settings, add our hooks/statusLine/permissions
        jq -s '
            # Start with their settings (index 1)
            .[1] as $existing |
            # Our template (index 0)
            .[0] as $template |

            # Merge strategy:
            # - permissions.allow: union (combine both)
            # - hooks: merge by type (combine hook arrays)
            # - statusLine: use ours if missing
            # - everything else: preserve theirs

            $existing |
            # Add our statusLine if missing
            (if .statusLine == null then .statusLine = $template.statusLine else . end) |
            # Merge permissions.allow
            (if .permissions.allow then
                .permissions.allow += $template.permissions.allow | .permissions.allow |= unique
             else
                .permissions = $template.permissions
             end) |
            # Merge hooks (deep merge by hook type)
            (if .hooks then
                .hooks = ($template.hooks * .hooks)
             else
                .hooks = $template.hooks
             end)
        ' "$AOA_DATA/settings.template.json" "$project_root/.claude/settings.local.json" \
          > "$project_root/.claude/settings.local.json.new"

        mv "$project_root/.claude/settings.local.json.new" "$project_root/.claude/settings.local.json"
        echo -e "${GREEN}‚úì${NC} ${DIM}(merged, backup created)${NC}"
    fi

    # Register project in projects.json
    echo -n "  Registering project........... "
    local projects_file="$AOA_DATA/projects.json"
    local now=$(date -Iseconds)

    # Create entry
    local entry=$(jq -n \
        --arg id "$project_id" \
        --arg name "$project_name" \
        --arg path "$project_root" \
        --arg added "$now" \
        '{id: $id, name: $name, path: $path, added: $added}')

    # Add to projects.json (remove existing entry with same id first)
    local updated=$(jq --arg id "$project_id" 'map(select(.id != $id))' "$projects_file")
    echo "$updated" | jq --argjson entry "$entry" '. + [$entry]' > "$projects_file.tmp"
    mv "$projects_file.tmp" "$projects_file"
    echo -e "${GREEN}‚úì${NC}"

    # Trigger initial index
    echo -n "  Indexing project.............. "
    local index_result=$(curl -s -X POST "${INDEX_URL}/project/register" \
        -H "Content-Type: application/json" \
        -d "{\"id\": \"${project_id}\", \"name\": \"${project_name}\", \"path\": \"${project_root}\"}" 2>/dev/null)

    if echo "$index_result" | jq -e '.success' > /dev/null 2>&1; then
        local file_count=$(echo "$index_result" | jq -r '.files // 0')
        echo -e "${GREEN}‚úì${NC} ${DIM}(${file_count} files)${NC}"
    else
        echo -e "${YELLOW}pending${NC} ${DIM}(will index on first search)${NC}"
    fi

    echo
    echo -e "${GREEN}${BOLD}‚úì aOa enabled for ${project_name}${NC}"
    echo
    echo -e "${DIM}Restart Claude Code to activate hooks.${NC}"
    echo -e "${DIM}Then try: aoa search <term>${NC}"
    echo
}

cmd_remove() {
    echo -e "${CYAN}${BOLD}‚ö° aOa - Removing from Project${NC}"
    echo

    local project_root=$(get_project_root)
    if [ -z "$project_root" ]; then
        echo -e "${RED}Not in a git repository.${NC}"
        return 1
    fi

    local project_id=$(get_project_id)
    local project_name=$(get_project_name)

    echo -e "  Project: ${BOLD}${project_name}${NC}"
    echo

    # Check if initialized
    if [ ! -f "$project_root/.claude/hooks/aoa-status-line.sh" ]; then
        echo -e "${DIM}aOa not initialized in this project.${NC}"
        return 0
    fi

    # Remove hooks
    echo -n "  Removing hooks................ "
    rm -f "$project_root/.claude/hooks/aoa-"* 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Remove skills (all aoa* folders and files)
    echo -n "  Removing skills............... "
    rm -rf "$project_root/.claude/skills/aoa"* 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Remove agents
    echo -n "  Removing agents............... "
    rm -f "$project_root/.claude/agents/aoa-"* 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Remove entire .aoa/ folder (full cleanup)
    echo -n "  Removing .aoa/ folder......... "
    rm -rf "$project_root/.aoa" 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Remove from projects.json
    echo -n "  Unregistering project......... "
    local projects_file="$AOA_DATA/projects.json"
    if [ -f "$projects_file" ]; then
        jq --arg id "$project_id" 'map(select(.id != $id))' "$projects_file" > "$projects_file.tmp"
        mv "$projects_file.tmp" "$projects_file"
    fi
    echo -e "${GREEN}‚úì${NC}"

    # Notify service to remove index
    echo -n "  Removing index................ "
    curl -s -X DELETE "${INDEX_URL}/project/${project_id}" > /dev/null 2>&1 || true
    echo -e "${GREEN}‚úì${NC}"

    # Clean up CLAUDE.md - remove aOa Integration section
    echo -n "  Cleaning CLAUDE.md............ "
    local claude_md="$project_root/CLAUDE.md"
    if [ -f "$claude_md" ] && grep -q "# aOa Integration" "$claude_md"; then
        # Remove the aOa Integration section (from marker to next # heading or EOF)
        sed -i '/^# aOa Integration$/,/^# [^a]/{/^# [^a]/!d}' "$claude_md" 2>/dev/null
        # Clean up any trailing empty lines
        sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$claude_md" 2>/dev/null
        echo -e "${GREEN}‚úì${NC}"
    else
        echo -e "${DIM}not present${NC}"
    fi

    # Restore settings from backup if available
    echo -n "  Restoring settings............ "
    # Find the most recent backup
    local backup=$(ls -t "$project_root/.claude/settings.local.json.pre-aoa-"* 2>/dev/null | head -1)

    if [ -f "$project_root/.claude/settings.local.json" ]; then
        if [ -n "$backup" ]; then
            # Backup exists - restore original settings
            mv "$backup" "$project_root/.claude/settings.local.json"
            # Clean up any other backups
            rm -f "$project_root/.claude/settings.local.json.pre-aoa-"* 2>/dev/null
            echo -e "${GREEN}restored from backup${NC}"
        else
            # No backup - check if it's just our template
            local template_hash=$(md5sum "$AOA_DATA/settings.template.json" 2>/dev/null | cut -d' ' -f1)
            local settings_hash=$(md5sum "$project_root/.claude/settings.local.json" 2>/dev/null | cut -d' ' -f1)

            if [ "$template_hash" = "$settings_hash" ]; then
                rm -f "$project_root/.claude/settings.local.json"
                echo -e "${GREEN}removed${NC}"
            else
                echo -e "${YELLOW}preserved (has customizations)${NC}"
            fi
        fi
    else
        echo -e "${DIM}not found${NC}"
    fi

    # Clean up empty directories
    echo -n "  Cleaning directories.......... "
    rmdir "$project_root/.claude/hooks" 2>/dev/null || true
    rmdir "$project_root/.claude/skills" 2>/dev/null || true
    rmdir "$project_root/.claude/agents" 2>/dev/null || true
    rmdir "$project_root/.claude" 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    echo
    echo -e "${GREEN}${BOLD}‚úì aOa removed from ${project_name}${NC}"
    echo
    echo -e "${DIM}Restart Claude Code to deactivate hooks.${NC}"
    echo
}

cmd_projects() {
    echo -e "${BOLD}aOa Projects${NC}"
    echo

    local projects_file="$AOA_DATA/projects.json"

    if [ ! -f "$projects_file" ]; then
        echo -e "${DIM}No projects registered.${NC}"
        echo -e "${DIM}Run 'aoa init' in a project to enable aOa.${NC}"
        return 0
    fi

    local count=$(jq 'length' "$projects_file" 2>/dev/null)

    if [ "$count" = "0" ] || [ -z "$count" ]; then
        echo -e "${DIM}No projects registered.${NC}"
        echo -e "${DIM}Run 'aoa init' in a project to enable aOa.${NC}"
        return 0
    fi

    # Get current project for highlighting
    local current_id=$(get_project_id)

    # List projects
    jq -r '.[] | "\(.id)|\(.name)|\(.path)"' "$projects_file" | while IFS='|' read -r id name path; do
        if [ "$id" = "$current_id" ]; then
            echo -e "  ${GREEN}‚ñ∏${NC} ${BOLD}${name}${NC} ${DIM}${path}${NC} ${GREEN}(current)${NC}"
        else
            # Check if path still exists
            if [ -d "$path" ]; then
                echo -e "  ${DIM}‚Ä¢${NC} ${name} ${DIM}${path}${NC}"
            else
                echo -e "  ${RED}‚úó${NC} ${name} ${DIM}${path}${NC} ${RED}(missing)${NC}"
            fi
        fi
    done

    echo
    echo -e "${DIM}${count} project(s) registered${NC}"
}

# =============================================================================
# Local Index Commands (default)
# =============================================================================

cmd_grep() {
    # aoa grep <term>           - Symbol search (O(1) indexed)
    # aoa grep "a b c"          - Multi-term OR search, ranked
    # aoa grep -a term1,term2   - Multi-term AND (all terms required)
    # aoa grep -i <term>        - Case insensitive
    # aoa grep --since 1h       - Files modified in last hour
    # aoa grep --today          - Files modified today (last 24h)
    # aoa grep --json           - Output as JSON
    # aoa grep -c               - Count only
    # aoa grep -q               - Quiet (exit code only)
    local and_mode=false
    local case_insensitive=false
    local word_boundary=false
    local json_output=false
    local count_only=false
    local quiet=false
    local query=""
    local mode="recent"
    local limit="20"
    local since=""
    local before=""

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -a|--and)
                and_mode=true
                shift
                ;;
            -i|--ignore-case)
                case_insensitive=true
                shift
                ;;
            -w|--word)
                word_boundary=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            -c|--count)
                count_only=true
                shift
                ;;
            -q|--quiet)
                quiet=true
                shift
                ;;
            -l|--limit)
                limit="$2"
                shift 2
                ;;
            -m|--mode)
                mode="$2"
                shift 2
                ;;
            --since)
                since="$2"
                shift 2
                ;;
            --before)
                before="$2"
                shift 2
                ;;
            --today)
                since="24h"
                shift
                ;;
            -*)
                echo "Unknown flag: $1"
                return 1
                ;;
            *)
                if [ -z "$query" ]; then
                    query="$1"
                fi
                shift
                ;;
        esac
    done

    # Parse time strings to seconds
    parse_time_to_seconds() {
        local time_str="$1"
        if [[ "$time_str" =~ ^([0-9]+)([smhd])$ ]]; then
            local num="${BASH_REMATCH[1]}"
            local unit="${BASH_REMATCH[2]}"
            case "$unit" in
                s) echo "$num" ;;
                m) echo $((num * 60)) ;;
                h) echo $((num * 3600)) ;;
                d) echo $((num * 86400)) ;;
            esac
        else
            echo "$time_str"
        fi
    }

    local since_seconds=""
    local before_seconds=""
    [ -n "$since" ] && since_seconds=$(parse_time_to_seconds "$since")
    [ -n "$before" ] && before_seconds=$(parse_time_to_seconds "$before")

    if [ -z "$query" ]; then
        echo "Usage: aoa grep <term> [options]"
        echo ""
        echo "Options:"
        echo "  -a, --and          AND mode: all comma-separated terms required"
        echo "  -i, --ignore-case  Case insensitive search"
        echo "  -w, --word         Word boundary match"
        echo "  -l, --limit N      Limit results (default: 20)"
        echo "  --since TIME       Files modified since TIME (e.g., 1h, 7d, 30m)"
        echo "  --before TIME      Files modified before TIME"
        echo "  --today            Shortcut for --since 24h"
        echo "  --json             Output as JSON"
        echo "  -c, --count        Show count only"
        echo "  -q, --quiet        Quiet mode (exit code only)"
        echo ""
        echo "Examples:"
        echo "  aoa grep handleAuth          # Symbol search"
        echo "  aoa grep \"auth token\"        # OR search (either term)"
        echo "  aoa grep -a auth,session     # AND search (all terms)"
        echo "  aoa grep auth --since 1h     # Modified in last hour"
        echo "  aoa grep auth --today        # Modified today"
        echo "  aoa grep auth --json         # JSON output"
        echo "  aoa grep auth -c             # Count only"
        return 1
    fi

    # === Smart Routing: detect regex patterns and route appropriately ===

    # Simple pipe OR: foo|bar or foo\|bar ‚Üí convert to space OR
    # This is the #1 friction point - users expect | to mean OR
    if [[ "$query" =~ ^[a-zA-Z0-9_]+([\\]?\|[a-zA-Z0-9_]+)+$ ]]; then
        # Convert pipes (escaped or not) to spaces for OR search
        local converted="${query//\\|/ }"
        converted="${converted//|/ }"
        echo -e "${DIM}(| ‚Üí OR search: ${converted})${NC}"
        query="$converted"

    # Glob pattern: starts with * or looks like *.ext ‚Üí suggest aoa find
    elif [[ "$query" == \** || "$query" == *'**'* ]]; then
        echo -e "${YELLOW}Tip:${NC} Use 'aoa find' for file patterns"
        echo -e "  ${DIM}aoa find \"$query\"${NC}"
        return 1

    # Complex regex: contains metacharacters that won't work in symbol search
    # Route to egrep for actual regex matching
    # Check for: . * + ? ^ $ [ ] { } ( ) \
    elif [[ "$query" == *'.'* || "$query" == *'*'* || "$query" == *'+'* || \
            "$query" == *'?'* || "$query" == *'^'* || "$query" == *'$'* || \
            "$query" == *'['* || "$query" == *'\'* || "$query" == *'('* ]] && \
         [[ ! "$query" =~ ^[a-zA-Z0-9_\ ]+$ ]]; then
        echo -e "${DIM}(regex detected ‚Üí pattern search)${NC}"
        cmd_egrep "$query"
        return $?
    fi

    # === End Smart Routing ===

    # Get current project context
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local result
    local ms
    local count

    if [ "$and_mode" = true ]; then
        # AND mode: use /multi endpoint
        local json_terms=$(echo "$query" | tr ',' '\n' | jq -R . | jq -s .)

        local body="{\"terms\": ${json_terms}, \"mode\": \"${mode}\", \"limit\": ${limit}"
        [ -n "$project_id" ] && body="${body}, \"project\": \"${project_id}\""
        [ -n "$since_seconds" ] && body="${body}, \"since\": ${since_seconds}"
        [ -n "$before_seconds" ] && body="${body}, \"before\": ${before_seconds}"
        body="${body}}"

        result=$(curl -s -X POST "${INDEX_URL}/multi" \
            -H "Content-Type: application/json" \
            -d "$body")

        ms=$(echo "$result" | jq -r '.ms // 0')
        count=$(echo "$result" | jq -r '.results | length')

        # Handle output flags
        if [ "$quiet" = true ]; then
            [ "$count" -gt 0 ] && return 0 || return 1
        elif [ "$json_output" = true ]; then
            echo "$result"
        elif [ "$count_only" = true ]; then
            echo "$count"
        else
            printf "${CYAN}${BOLD}‚ö° %s hits${NC} ${DIM}‚îÇ${NC} ${GREEN}%.2fms${NC}\n" "$count" "$ms"
            echo "$result" | jq -r '.results[] | "  \(.file):\(.line)"' 2>/dev/null
        fi
    else
        # Default: symbol search with /symbol endpoint
        local encoded_query=$(printf '%s' "$query" | jq -sRr @uri)

        # Build query params
        local params="q=${encoded_query}&mode=${mode}&limit=${limit}${project_param}"
        [ "$case_insensitive" = true ] && params="${params}&ci=1"
        [ "$word_boundary" = true ] && params="${params}&word=1"
        [ -n "$since_seconds" ] && params="${params}&since=${since_seconds}"
        [ -n "$before_seconds" ] && params="${params}&before=${before_seconds}"

        result=$(curl -s "${INDEX_URL}/symbol?${params}")
        ms=$(echo "$result" | jq -r '.ms // 0')
        count=$(echo "$result" | jq -r '.results | length')

        # Handle output flags
        if [ "$quiet" = true ]; then
            [ "$count" -gt 0 ] && return 0 || return 1
        elif [ "$json_output" = true ]; then
            echo "$result"
        elif [ "$count_only" = true ]; then
            echo "$count"
        else
            printf "${CYAN}${BOLD}‚ö° %s hits${NC} ${DIM}‚îÇ${NC} ${GREEN}%.2fms${NC}\n" "$count" "$ms"

            # Results - show symbol metadata when available
            echo "$result" | jq -r '.results[] |
              if .symbol then
                "  \(.file):\(.line) \(.symbol_kind // ""):\(.symbol) [\(.line)-\(.end_line // .line)]"
              else
                "  \(.file):\(.line)"
              end' 2>/dev/null
        fi
    fi
}

# Deprecated: use cmd_grep instead
cmd_search() {
    cmd_grep "$@"
}

# Deprecated: use cmd_grep -a instead
cmd_multi() {
    cmd_grep -a "$@"
}

cmd_changes() {
    local since="${1:-300}"
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    # Parse time strings
    if [[ "$since" =~ ^([0-9]+)([smh])$ ]]; then
        local num="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2]}"
        case "$unit" in
            s) since=$num ;;
            m) since=$((num * 60)) ;;
            h) since=$((num * 3600)) ;;
        esac
    fi

    local result=$(curl -s "${INDEX_URL}/changes?since=${since}${project_param}")

    echo -e "${GREEN}Added:${NC}"
    echo "$result" | jq -r '.added[]' 2>/dev/null || echo "  (none)"

    echo -e "${YELLOW}Modified:${NC}"
    echo "$result" | jq -r '.modified[].file' 2>/dev/null || echo "  (none)"

    echo -e "${RED}Deleted:${NC}"
    echo "$result" | jq -r '.deleted[]' 2>/dev/null || echo "  (none)"
}

cmd_files() {
    local pattern="$1"
    local mode="${2:-recent}"
    local limit="${3:-30}"

    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local url="${INDEX_URL}/files?mode=${mode}&limit=${limit}${project_param}"
    [ -n "$pattern" ] && url="${url}&match=${pattern}"

    curl -s "$url" | jq -r '.results[] | "\(.path) (\(.language))"'
}

# =============================================================================
# File Discovery Commands (Unix parity)
# =============================================================================

cmd_find() {
    # aoa find <pattern>         - Find files by glob pattern
    # aoa find -type py          - Find files by language
    # aoa find "*.py" --recent   - Recently modified Python files
    local pattern=""
    local lang=""
    local mode="recent"
    local limit="50"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -type|-t)
                lang="$2"
                shift 2
                ;;
            --recent|-r)
                mode="recent"
                shift
                ;;
            --alpha|-a)
                mode="alpha"
                shift
                ;;
            -l|--limit)
                limit="$2"
                shift 2
                ;;
            -*)
                echo "Unknown flag: $1"
                return 1
                ;;
            *)
                pattern="$1"
                shift
                ;;
        esac
    done

    if [ -z "$pattern" ] && [ -z "$lang" ]; then
        echo "Usage: aoa find <pattern> [options]"
        echo ""
        echo "Options:"
        echo "  -type, -t <lang>   Filter by language (py, js, ts, go, etc.)"
        echo "  --recent, -r       Sort by modification time (default)"
        echo "  --alpha, -a        Sort alphabetically"
        echo "  -l, --limit N      Limit results (default: 50)"
        echo ""
        echo "Examples:"
        echo "  aoa find '*.py'          # All Python files"
        echo "  aoa find -type py        # Same, by language"
        echo "  aoa find 'test*.py'      # Test files"
        echo "  aoa find 'src/**/*.ts'   # TypeScript in src/"
        return 1
    fi

    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local url="${INDEX_URL}/files?mode=${mode}&limit=${limit}${project_param}"
    [ -n "$pattern" ] && url="${url}&match=${pattern}"
    [ -n "$lang" ] && url="${url}&lang=${lang}"

    local result=$(curl -s "$url")
    local count=$(echo "$result" | jq -r '.results | length')

    printf "${CYAN}${BOLD}üìÅ %s files${NC}\n" "$count"
    echo "$result" | jq -r '.results[] | "  \(.path)"'
}

cmd_tree() {
    # aoa tree [dir]     - Show directory structure
    local dir="${1:-.}"
    local depth="${2:-3}"

    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    # Use /files endpoint and build tree structure
    local result=$(curl -s "${INDEX_URL}/files?mode=alpha&limit=500${project_param}")

    # Filter to directory if specified
    if [ "$dir" != "." ]; then
        result=$(echo "$result" | jq --arg dir "$dir" '.results |= map(select(.path | startswith($dir)))')
    fi

    local count=$(echo "$result" | jq -r '.results | length')
    local dirs=$(echo "$result" | jq -r '[.results[].path | split("/")[:-1] | join("/")] | unique | length')

    printf "${CYAN}${BOLD}üå≥ %s dirs, %s files${NC}\n" "$dirs" "$count"
    echo ""

    # Simple tree-like output
    echo "$result" | jq -r '.results[].path' | while read -r path; do
        local indent=$(echo "$path" | tr -cd '/' | wc -c)
        local name=$(basename "$path")
        printf "%*s%s\n" $((indent * 2)) "" "$name"
    done | head -50
}

cmd_locate() {
    # aoa locate <name>   - Fast filename search (uses symbol index)
    local name="$1"

    if [ -z "$name" ]; then
        echo "Usage: aoa locate <filename>"
        echo ""
        echo "Examples:"
        echo "  aoa locate routes       # Find files with 'routes' in name"
        echo "  aoa locate config.py    # Find config.py files"
        return 1
    fi

    # Search in filenames using /files endpoint
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/files?match=*${name}*&limit=20${project_param}")
    local count=$(echo "$result" | jq -r '.results | length')

    printf "${CYAN}${BOLD}üîç %s matches${NC}\n" "$count"
    echo "$result" | jq -r '.results[] | "  \(.path)"'
}

cmd_head() {
    # aoa head <file> [n]   - Show first n lines (default: 20)
    local file="$1"
    local lines="${2:-20}"

    if [ -z "$file" ]; then
        echo "Usage: aoa head <file> [lines]"
        echo ""
        echo "Examples:"
        echo "  aoa head cli/aoa        # First 20 lines"
        echo "  aoa head cli/aoa 50     # First 50 lines"
        return 1
    fi

    # Use /file endpoint with line range
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/file?path=${file}&lines=1-${lines}${project_param}")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    printf "${DIM}%s (lines 1-%s)${NC}\n" "$file" "$lines"
    echo "$result" | jq -r '.content // .lines[]'
}

cmd_tail() {
    # aoa tail <file> [n]   - Show last n lines (default: 20)
    local file="$1"
    local lines="${2:-20}"

    if [ -z "$file" ]; then
        echo "Usage: aoa tail <file> [lines]"
        echo ""
        echo "Examples:"
        echo "  aoa tail cli/aoa        # Last 20 lines"
        echo "  aoa tail cli/aoa 50     # Last 50 lines"
        return 1
    fi

    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/file?path=${file}&lines=-${lines}${project_param}")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    printf "${DIM}%s (last %s lines)${NC}\n" "$file" "$lines"
    echo "$result" | jq -r '.content // .lines[]'
}

cmd_lines() {
    # aoa lines <file> <range>   - Show specific line range
    local file="$1"
    local range="$2"

    if [ -z "$file" ] || [ -z "$range" ]; then
        echo "Usage: aoa lines <file> <start-end>"
        echo ""
        echo "Examples:"
        echo "  aoa lines cli/aoa 100-150   # Lines 100-150"
        echo "  aoa lines cli/aoa 500-550   # Lines 500-550"
        return 1
    fi

    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/file?path=${file}&lines=${range}${project_param}")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    printf "${DIM}%s (lines %s)${NC}\n" "$file" "$range"
    echo "$result" | jq -r '.content // .lines[]'
}

# =============================================================================
# Behavioral Commands (aOa unique - no Unix equivalent)
# =============================================================================

cmd_hot() {
    # aoa hot [limit]     - Show frequently accessed "hot" files
    local limit="${1:-10}"

    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/predict?limit=${limit}${project_param}")
    local count=$(echo "$result" | jq -r '.predictions | length // 0' 2>/dev/null || echo "0")

    printf "${CYAN}${BOLD}üî• %s hot files${NC}\n" "$count"

    if [ "$count" -gt 0 ] 2>/dev/null; then
        echo "$result" | jq -r '.predictions[] | "  \(.file) (\(.score | . * 100 | floor)%)"' 2>/dev/null || true
    fi
    return 0
}

cmd_touched() {
    # aoa touched [since]   - Files touched in current session or time period
    local since="${1:-session}"

    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    # Parse time string
    local since_param="since=session"
    if [[ "$since" =~ ^([0-9]+)([smhd])$ ]]; then
        local num="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2]}"
        local seconds
        case "$unit" in
            s) seconds=$num ;;
            m) seconds=$((num * 60)) ;;
            h) seconds=$((num * 3600)) ;;
            d) seconds=$((num * 86400)) ;;
        esac
        since_param="since=${seconds}"
    elif [ "$since" = "session" ]; then
        since_param="since=session"
    elif [ "$since" = "today" ]; then
        since_param="since=86400"
    fi

    local result=$(curl -s "${INDEX_URL}/intent/recent?${since_param}&limit=100${project_param}")

    # Extract unique files from intent records
    local files=$(echo "$result" | jq -r '[.intents[]?.files[]?] | unique | .[]' 2>/dev/null || true)
    local count=0
    if [ -n "$files" ]; then
        count=$(echo "$files" | wc -l | tr -d ' ')
    fi

    printf "${CYAN}${BOLD}‚úã %s files touched${NC}\n" "$count"
    if [ -n "$files" ]; then
        echo "$files" | while read -r file; do
            [ -n "$file" ] && echo "  $file"
        done
    fi
    return 0
}

cmd_focus() {
    # aoa focus     - Show current working set from memory
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="?project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/memory${project_param}")
    local count=$(echo "$result" | jq -r '.working_set | length // 0' 2>/dev/null || echo "0")

    printf "${CYAN}${BOLD}üéØ %s files in focus${NC}\n" "$count"

    if [ "$count" -gt 0 ] 2>/dev/null; then
        echo "$result" | jq -r '.working_set[]' 2>/dev/null | while read -r file; do
            echo "  $file"
        done
    fi
    return 0
}

cmd_predict() {
    # aoa predict [file]   - Predict next files based on current context
    local file="$1"

    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local url="${INDEX_URL}/transitions/predict?limit=5${project_param}"
    if [ -n "$file" ]; then
        url="${url}&file=${file}"
    fi

    local result=$(curl -s "$url")
    local count=$(echo "$result" | jq -r '.predictions | length // 0' 2>/dev/null || echo "0")

    if [ -n "$file" ]; then
        printf "${CYAN}${BOLD}üîÆ %s predictions for %s${NC}\n" "$count" "$file"
    else
        printf "${CYAN}${BOLD}üîÆ %s predictions${NC}\n" "$count"
    fi

    if [ "$count" -gt 0 ] 2>/dev/null; then
        echo "$result" | jq -r '.predictions[] | "  \(.file) (\(.confidence | . * 100 | floor)% confidence)"' 2>/dev/null || true
    fi
    return 0
}

cmd_outline() {
    local file=""
    local enrich=false
    local enrich_all=false
    local pending=false
    local json_output=false
    local store=false
    local show_tags=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --enrich)
                enrich=true
                shift
                ;;
            --enrich-all)
                enrich_all=true
                shift
                ;;
            --pending)
                pending=true
                shift
                ;;
            --json|-j)
                json_output=true
                shift
                ;;
            --store)
                store=true
                shift
                ;;
            --tags|-t)
                show_tags=true
                shift
                ;;
            -*)
                echo "Unknown option: $1"
                return 1
                ;;
            *)
                file="$1"
                shift
                ;;
        esac
    done

    # Handle --store (post enriched tags from stdin)
    if $store; then
        local project_id=$(get_project_id)
        local json_input=$(cat)

        # Add project_id if not present
        if [ -n "$project_id" ]; then
            json_input=$(echo "$json_input" | jq --arg pid "$project_id" '. + {project: $pid}')
        fi

        local result=$(echo "$json_input" | curl -s -X POST "${INDEX_URL}/outline/enriched" \
            -H "Content-Type: application/json" \
            -d @-)

        if $json_output; then
            echo "$result" | jq .
        else
            local success=$(echo "$result" | jq -r '.success // false')
            if [ "$success" = "true" ]; then
                local tags_count=$(echo "$result" | jq -r '.tags_indexed // 0')
                local symbols_count=$(echo "$result" | jq -r '.symbols_processed // 0')
                echo -e "${GREEN}‚úì${NC} Stored ${tags_count} tags across ${symbols_count} symbols"

                # Record to intent system for activity tracking
                local file_path=$(echo "$json_input" | jq -r '.file // ""')
                local tags=$(echo "$json_input" | jq -c '[.symbols[].tags[]?] | unique | .[0:5]')
                if [ -n "$file_path" ] && [ "$tags" != "[]" ]; then
                    curl -s -X POST "${INDEX_URL}/intent" \
                        -H "Content-Type: application/json" \
                        -d "{\"tool\": \"Outline\", \"files\": [\"$file_path\"], \"tags\": $tags, \"project_id\": \"$project_id\"}" > /dev/null 2>&1
                fi
            else
                local err=$(echo "$result" | jq -r '.error // "Unknown error"')
                echo -e "${RED}‚úó${NC} ${err}"
                return 1
            fi
        fi
        return 0
    fi

    # Handle --pending (quick status check)
    if $pending; then
        local project_id=$(get_project_id)
        local project_param=""
        if [ -n "$project_id" ]; then
            project_param="?project=${project_id}"
        fi

        local result=$(curl -s "${INDEX_URL}/outline/pending${project_param}")

        # JSON output for agents/scripts
        if $json_output; then
            echo "$result" | jq .
            return 0
        fi

        local pending_count=$(echo "$result" | jq -r '.pending_count // 0')
        local up_to_date=$(echo "$result" | jq -r '.up_to_date_count // 0')
        local total=$(echo "$result" | jq -r '.total_files // 0')

        echo -e "${CYAN}${BOLD}‚ö° aOa Outline Status${NC}"
        echo ""
        echo -e "  Pending:  ${YELLOW}${pending_count}${NC} need tags"
        echo -e "  Tagged:   ${GREEN}${up_to_date}${NC}"
        echo -e "  Total:    ${total}"

        if [ "$pending_count" -gt 0 ]; then
            echo ""
            echo -e "${DIM}In Claude Code, say: \"tag the codebase\"${NC}"
        else
            echo ""
            echo -e "${DIM}Search tags: aoa search \"#validation\"${NC}"
        fi
        return 0
    fi

    # Handle --enrich-all (batch mode - now "deep outline")
    if $enrich_all; then
        echo -e "${CYAN}${BOLD}‚ö° aOa Outline - Deep Tagging${NC}"
        echo ""

        # Get current project context
        local project_id=$(get_project_id)
        local project_param=""
        if [ -n "$project_id" ]; then
            project_param="?project=${project_id}"
        fi

        # Get pending files from the service
        local result=$(curl -s "${INDEX_URL}/outline/pending${project_param}")

        local pending_count=$(echo "$result" | jq -r '.pending_count // 0')
        local up_to_date=$(echo "$result" | jq -r '.up_to_date_count // 0')
        local total=$(echo "$result" | jq -r '.total_files // 0')
        local ms=$(echo "$result" | jq -r '.ms // 0')

        printf "Scanned project in ${GREEN}%.1fms${NC}\n" "$ms"
        echo ""
        echo -e "  Total files:   ${BOLD}${total}${NC}"
        echo -e "  Tagged:        ${GREEN}${up_to_date}${NC}"
        echo -e "  Need tags:     ${YELLOW}${pending_count}${NC}"
        echo ""

        if [ "$pending_count" -eq 0 ]; then
            echo -e "${GREEN}All files are tagged!${NC}"
            echo ""
            echo -e "${DIM}Search: aoa search \"#validation\"${NC}"
            return 0
        fi

        echo -e "${BOLD}Files needing tags:${NC}"
        echo "$result" | jq -r '.pending[:10][] | "  \(.file) (\(.reason))"' 2>/dev/null

        if [ "$pending_count" -gt 10 ]; then
            echo -e "  ${DIM}... and $((pending_count - 10)) more${NC}"
        fi

        echo ""
        echo -e "${BOLD}To tag these files:${NC}"
        echo ""
        echo "  In Claude Code, say: \"tag the codebase\""
        echo ""
        return 0
    fi

    if [ -z "$file" ]; then
        echo "Usage: aoa outline <file>"
        echo "       aoa outline <file> --tags"
        echo "       aoa outline --pending"
        echo ""
        echo "Options:"
        echo "  --tags, -t    Show semantic tags for each symbol"
        echo "  --pending     Show files needing semantic tags"
        echo "  --enrich-all  Show detailed tagging status"
        echo "  --json, -j    Output as JSON"
        echo ""
        echo "To add semantic tags, say in Claude Code: \"tag the codebase\""
        echo ""
        echo "Examples:"
        echo "  aoa outline src/index.ts"
        echo "  aoa outline src/index.ts --tags"
        echo "  aoa outline --pending"
        return 1
    fi

    # Get current project context
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/outline?file=${file}${project_param}")

    # JSON output for agents/scripts
    if $json_output; then
        echo "$result" | jq .
        return 0
    fi

    # Check for errors
    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        local msg=$(echo "$result" | jq -r '.message // empty')
        [ -n "$msg" ] && echo -e "${DIM}${msg}${NC}"
        return 1
    fi

    local count=$(echo "$result" | jq -r '.count // 0')
    local ms=$(echo "$result" | jq -r '.ms // 0')
    local lang=$(echo "$result" | jq -r '.language // "unknown"')

    # Header
    if $enrich; then
        printf "${CYAN}${BOLD}‚ö° %s symbols${NC} ${DIM}‚îÇ${NC} ${GREEN}%.2fms${NC} ${DIM}‚îÇ${NC} ${YELLOW}%s${NC} ${DIM}‚îÇ${NC} ${BLUE}enrichment requested${NC}\n" "$count" "$ms" "$lang"
    elif $show_tags; then
        printf "${CYAN}${BOLD}‚ö° %s symbols${NC} ${DIM}‚îÇ${NC} ${GREEN}%.2fms${NC} ${DIM}‚îÇ${NC} ${YELLOW}%s${NC} ${DIM}‚îÇ${NC} ${CYAN}with tags${NC}\n" "$count" "$ms" "$lang"
    else
        printf "${CYAN}${BOLD}‚ö° %s symbols${NC} ${DIM}‚îÇ${NC} ${GREEN}%.2fms${NC} ${DIM}‚îÇ${NC} ${YELLOW}%s${NC}\n" "$count" "$ms" "$lang"
    fi
    echo ""

    # Output symbols with line ranges (and tags if requested)
    if $show_tags; then
        # Fetch tags for this file from the inverted index
        local tags_json=$(curl -s "${INDEX_URL}/outline/tags?file=${file}${project_param}" 2>/dev/null)

        # Use jq to format output with tags inline
        echo "$result" | jq -r --argjson tags "$tags_json" '
            .symbols[] |
            .kind as $kind |
            .name as $name |
            .start_line as $start |
            .end_line as $end |
            ($tags.tags[$name] // []) | join(" ") as $sym_tags |
            if ($sym_tags | length) > 0 then
                "  \($kind) \($name) [\($start)-\($end)] \($sym_tags)"
            else
                "  \($kind) \($name) [\($start)-\($end)] (no tags)"
            end
        ' 2>/dev/null
    else
        echo "$result" | jq -r '.symbols[] | "  \(.kind) \(.name) [\(.start_line)-\(.end_line)]"' 2>/dev/null
    fi

    # If tagging requested, output instructions for Claude
    if $enrich; then
        echo ""
        echo -e "${BLUE}‚îÄ‚îÄ‚îÄ Semantic Tagging ‚îÄ‚îÄ‚îÄ${NC}"
        echo ""
        echo -e "${DIM}To tag these symbols, Claude should:${NC}"
        echo -e "${DIM}1. Analyze the symbols above${NC}"
        echo -e "${DIM}2. Generate 2-5 semantic tags per symbol via Haiku${NC}"
        echo -e "${DIM}3. Store via: POST /outline/enriched with symbols array${NC}"
        echo ""
        # Output JSON for Claude to use
        echo "TAG_REQUEST:"
        echo "$result" | jq -c '{file: .file, language: .language, symbols: [.symbols[] | {name: .name, kind: .kind, line: .start_line, end_line: .end_line, signature: .signature}]}'
    fi
}

cmd_outline_status() {
    # Show outline tagging status
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="?project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/outline/pending${project_param}")
    local pending_count=$(echo "$result" | jq -r '.pending_count // 0')
    local up_to_date=$(echo "$result" | jq -r '.up_to_date_count // 0')
    local total=$(echo "$result" | jq -r '.total_files // 0')

    echo -e "${CYAN}${BOLD}‚ö° aOa Outline${NC}"
    echo ""
    echo -e "  Pending:  ${YELLOW}${pending_count}${NC} files need semantic tags"
    echo -e "  Tagged:   ${GREEN}${up_to_date}${NC} files"
    echo -e "  Total:    ${total} files"
    echo ""

    if [ "$pending_count" -eq 0 ]; then
        echo -e "${GREEN}All files are tagged!${NC}"
        echo ""
        echo "Try: aoa search \"#authentication\" to find auth code"
        return 0
    fi

    echo -e "${BOLD}How to tag:${NC}"
    echo ""
    echo "  In Claude Code, say: \"tag the codebase\""
    echo ""
    echo "  Claude will:"
    echo "    1. Get pending files from /outline/pending"
    echo "    2. Batch files into groups of 15"
    echo "    3. Generate semantic tags per symbol via Haiku"
    echo "    4. Store tags for searchable access"
    echo ""
    echo -e "${DIM}Then search: aoa search \"#validation\" to find by tag${NC}"
}

# =============================================================================
# Knowledge Repo Commands
# =============================================================================

cmd_repo() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)
            cmd_repo_list "$@"
            ;;
        add)
            cmd_repo_add "$@"
            ;;
        remove|rm)
            cmd_repo_remove "$@"
            ;;
        *)
            # Assume it's a repo name - dispatch to repo-specific commands
            local repo_name="$subcmd"
            local repo_cmd="${1:-help}"
            shift || true

            case "$repo_cmd" in
                search|s)
                    cmd_repo_search "$repo_name" "$@"
                    ;;
                multi|m)
                    cmd_repo_multi "$repo_name" "$@"
                    ;;
                files|f)
                    cmd_repo_files "$repo_name" "$@"
                    ;;
                file)
                    cmd_repo_file "$repo_name" "$@"
                    ;;
                deps)
                    cmd_repo_deps "$repo_name" "$@"
                    ;;
                *)
                    echo -e "${BOLD}Repo: ${repo_name}${NC}"
                    echo ""
                    echo "Commands:"
                    echo "  aoa repo ${repo_name} search <term>   Search in ${repo_name}"
                    echo "  aoa repo ${repo_name} multi <t1,t2>  Multi-term search"
                    echo "  aoa repo ${repo_name} files [pat]    List files"
                    echo "  aoa repo ${repo_name} file <path>    Get file content"
                    echo "  aoa repo ${repo_name} deps <file>    Get dependencies"
                    ;;
            esac
            ;;
    esac
}

cmd_repo_list() {
    echo -e "${BOLD}Knowledge Repos${NC}"
    echo ""

    local result=$(curl -s "${INDEX_URL}/repos")
    local count=$(echo "$result" | jq '.repos | length')

    if [ "$count" == "0" ]; then
        echo -e "${DIM}No knowledge repos. Add one with:${NC}"
        echo "  aoa repo add <name> <git-url>"
        return
    fi

    echo "$result" | jq -r '.repos[] | "  \(.name): \(.files) files, \(.symbols) symbols"'
}

cmd_repo_add() {
    local name="$1"
    local url="$2"

    if [ -z "$name" ] || [ -z "$url" ]; then
        echo "Usage: aoa repo add <name> <git-url>"
        echo ""
        echo "Examples:"
        echo "  aoa repo add flask https://github.com/pallets/flask"
        echo "  aoa repo add react https://github.com/facebook/react"
        return 1
    fi

    echo -e "${DIM}Cloning and indexing ${name}...${NC}"

    local result=$(curl -s -X POST "${INDEX_URL}/repos" \
        -H "Content-Type: application/json" \
        -d "{\"name\": \"${name}\", \"url\": \"${url}\"}")

    local success=$(echo "$result" | jq -r '.success // false')

    if [ "$success" == "true" ]; then
        local msg=$(echo "$result" | jq -r '.message')
        echo -e "${GREEN}${msg}${NC}"
    else
        local err=$(echo "$result" | jq -r '.error // "Unknown error"')
        echo -e "${RED}Failed: ${err}${NC}"
        return 1
    fi
}

cmd_repo_remove() {
    local name="$1"

    if [ -z "$name" ]; then
        echo "Usage: aoa repo remove <name>"
        return 1
    fi

    echo -e "${DIM}Removing ${name}...${NC}"

    local result=$(curl -s -X DELETE "${INDEX_URL}/repos/${name}")

    local success=$(echo "$result" | jq -r '.success // false')

    if [ "$success" == "true" ]; then
        echo -e "${GREEN}Repo '${name}' removed${NC}"
    else
        local err=$(echo "$result" | jq -r '.error // "Unknown error"')
        echo -e "${RED}Failed: ${err}${NC}"
        return 1
    fi
}

cmd_repo_search() {
    local repo_name="$1"
    local query="$2"
    local mode="${3:-recent}"
    local limit="${4:-20}"

    if [ -z "$query" ]; then
        echo "Usage: aoa repo ${repo_name} search <term> [mode] [limit]"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/repo/${repo_name}/symbol?q=${query}&mode=${mode}&limit=${limit}")

    # Check for error
    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    local ms=$(echo "$result" | jq -r '.ms // 0')
    local count=$(echo "$result" | jq -r '.results | length')

    # Single punchy line with repo indicator
    printf "${CYAN}${BOLD}‚ö° %s hits${NC} ${DIM}‚îÇ${NC} ${GREEN}%.2fms${NC} ${DIM}‚îÇ${NC} ${YELLOW}%s${NC}\n" "$count" "$ms" "$repo_name"

    echo "$result" | jq -r '.results[] | "  \(.file):\(.line)"' 2>/dev/null
}

cmd_repo_multi() {
    local repo_name="$1"
    local terms="$2"
    local mode="${3:-recent}"
    local limit="${4:-20}"

    if [ -z "$terms" ]; then
        echo "Usage: aoa repo ${repo_name} multi <term1,term2,...> [mode] [limit]"
        return 1
    fi

    local json_terms=$(echo "$terms" | tr ',' '\n' | jq -R . | jq -s .)

    local result=$(curl -s -X POST "${INDEX_URL}/repo/${repo_name}/multi" \
        -H "Content-Type: application/json" \
        -d "{\"terms\": ${json_terms}, \"mode\": \"${mode}\", \"limit\": ${limit}}")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    local ms=$(echo "$result" | jq -r '.ms // 0')

    echo -e "${DIM}Found in ${ms}ms (${repo_name}):${NC}"
    echo "$result" | jq -r '.results[] | "\(.file):\(.line)"' 2>/dev/null || echo "No results"
}

cmd_repo_files() {
    local repo_name="$1"
    local pattern="$2"
    local mode="${3:-recent}"
    local limit="${4:-30}"

    local url="${INDEX_URL}/repo/${repo_name}/files?mode=${mode}&limit=${limit}"
    [ -n "$pattern" ] && url="${url}&match=${pattern}"

    local result=$(curl -s "$url")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    echo "$result" | jq -r '.results[] | "\(.path) (\(.language))"'
}

cmd_repo_file() {
    local repo_name="$1"
    local path="$2"
    local lines="$3"

    if [ -z "$path" ]; then
        echo "Usage: aoa repo ${repo_name} file <path> [lines]"
        echo "  lines: e.g., 10-50"
        return 1
    fi

    local url="${INDEX_URL}/repo/${repo_name}/file?path=${path}"
    [ -n "$lines" ] && url="${url}&lines=${lines}"

    local result=$(curl -s "$url")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    echo "$result" | jq -r '.content'
}

cmd_repo_deps() {
    local repo_name="$1"
    local file="$2"
    local direction="${3:-outgoing}"

    if [ -z "$file" ]; then
        echo "Usage: aoa repo ${repo_name} deps <file> [outgoing|incoming]"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/repo/${repo_name}/deps?file=${file}&direction=${direction}")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    echo -e "${BOLD}${direction} dependencies for ${file}:${NC}"
    echo "$result" | jq -r '.dependencies[]' 2>/dev/null || echo "  (none)"
}

# =============================================================================
# Extended Regex Search (egrep)
# =============================================================================

cmd_egrep() {
    # aoa egrep "regex"                    - Simple regex search
    # aoa egrep '{"name": "regex"}'        - Named pattern (legacy JSON format)
    # aoa egrep "regex" --repo flask       - Search in knowledge repo
    # aoa egrep "regex" --since 7d         - Filter by time
    local pattern="$1"
    shift || true

    local repo=""
    local since=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --repo|-r) repo="$2"; shift 2 ;;
            --since|-s) since="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    if [ -z "$pattern" ]; then
        echo "Usage: aoa egrep <regex> [--repo name] [--since time]"
        echo ""
        echo "Examples:"
        echo '  aoa egrep "TODO|FIXME"                # Simple regex'
        echo '  aoa egrep "def\\s+handle\\w+"         # Function pattern'
        echo '  aoa egrep "class\\s+\\w+" --since 7d  # With time filter'
        echo '  aoa egrep "Blueprint" --repo flask    # In knowledge repo'
        echo ""
        echo "Note: Searches working set (~30-50 recent files), not full index."
        echo "      Use 'aoa grep' for full indexed search."
        return 1
    fi

    # Parse since time string
    local since_seconds=""
    if [ -n "$since" ]; then
        if [[ "$since" =~ ^([0-9]+)([smhd])$ ]]; then
            local num="${BASH_REMATCH[1]}"
            local unit="${BASH_REMATCH[2]}"
            case "$unit" in
                s) since_seconds=$num ;;
                m) since_seconds=$((num * 60)) ;;
                h) since_seconds=$((num * 3600)) ;;
                d) since_seconds=$((num * 86400)) ;;
            esac
        else
            since_seconds="$since"
        fi
    fi

    # Handle both simple string and JSON pattern formats
    local patterns
    if [[ "$pattern" == "{"* ]]; then
        # Already JSON format
        patterns="$pattern"
    else
        # Simple string - wrap in JSON with "match" key
        local escaped=$(printf '%s' "$pattern" | jq -Rs .)
        patterns="{\"match\": ${escaped}}"
    fi

    # Build request body
    local body="{\"patterns\": ${patterns}"
    [ -n "$repo" ] && body="${body}, \"repo\": \"${repo}\""
    [ -n "$since_seconds" ] && body="${body}, \"since\": ${since_seconds}"
    body="${body}}"

    local url="${INDEX_URL}/pattern"
    [ -n "$repo" ] && url="${INDEX_URL}/repo/${repo}/pattern"

    local result=$(curl -s -X POST "$url" \
        -H "Content-Type: application/json" \
        -d "$body")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    local ms=$(echo "$result" | jq -r '.stats.ms')
    local files=$(echo "$result" | jq -r '.stats.files_searched')
    local matched=$(echo "$result" | jq -r '.stats.files_matched')

    # Count total hits (sum of all matches across files)
    local hits=$(echo "$result" | jq '[.results | to_entries[].value | length] | add // 0')

    # Format ms to 2 decimal places
    local ms_fmt=$(printf "%.2f" "$ms")

    # Consistent branding with grep output
    printf "${CYAN}${BOLD}‚ö° %s hits${NC} ${DIM}‚îÇ${NC} ${GREEN}%sms${NC} ${DIM}‚îÇ${NC} %s files\n" "$hits" "$ms_fmt" "$files"

    # Output results (simplified - just file:line with context)
    echo "$result" | jq -r '.results | to_entries[].value[] | "  \(.file):\(.line) \u001b[2m\(.context)\u001b[0m"'
}

# Deprecated: use cmd_egrep instead
cmd_pattern() {
    cmd_egrep "$@"
}

# =============================================================================
# Intent Commands
# =============================================================================

cmd_intent() {
    local subcmd="${1:-recent}"
    shift || true

    case "$subcmd" in
        recent|r)
            cmd_intent_recent "$@"
            ;;
        tags|t)
            cmd_intent_tags "$@"
            ;;
        files|f)
            cmd_intent_files "$@"
            ;;
        file)
            cmd_intent_file "$@"
            ;;
        stats)
            cmd_intent_stats "$@"
            ;;
        store|s)
            cmd_intent_store "$@"
            ;;
        *)
            echo -e "${BOLD}Intent Tracking${NC}"
            echo ""
            echo "Commands:"
            echo "  aoa intent recent [since]   Recent intent records (e.g., 1h, 30m)"
            echo "  aoa intent tags             All tags with file counts"
            echo "  aoa intent files <tag>      Files associated with a tag"
            echo "  aoa intent file <path>      Tags associated with a file"
            echo "  aoa intent stats            Intent index statistics"
            echo "  aoa intent store <tags> [files...]  Store AI-generated intent tags"
            ;;
    esac
}

cmd_intent_recent() {
    local limit="${1:-20}"
    local project_id=$(get_project_id)

    # Get metrics for header
    local metrics=$(curl -s "${INDEX_URL}/metrics?project_id=${project_id}")
    local tokens_saved=$(echo "$metrics" | jq -r '.savings.tokens // 0')
    local time_saved_sec=$(echo "$metrics" | jq -r '.savings.time_sec // 0')
    local hit_pct=$(echo "$metrics" | jq -r '.rolling.hit_at_5_pct // 0')
    local evaluated=$(echo "$metrics" | jq -r '.rolling.evaluated // 0')
    local hits=$(echo "$metrics" | jq -r '.rolling.hits // 0')

    # Get recent intent records
    local result=$(curl -s "${INDEX_URL}/intent/recent?limit=${limit}&project_id=${project_id}")
    local total=$(echo "$result" | jq -r '.stats.total_records // 0')

    # Format tokens with k suffix
    local tokens_k=$(awk "BEGIN {printf \"%.0f\", $tokens_saved/1000}")
    local hit_pct_int=$(printf "%.0f" "$hit_pct")

    # Calculate dynamic rate from rolling windows (5, 15, 30 min)
    local rate_data=$(python3 << 'PYEOF'
import json
import os
from pathlib import Path
from datetime import datetime, timedelta

home = os.path.expanduser('~')
projects_dir = Path(home) / '.claude' / 'projects'

if not projects_dir.exists():
    print(json.dumps({'rate_low': 2.0, 'rate_high': 5.0, 'samples': 0}))
    exit()

# Get recent session files
sessions = []
for project_dir in sorted(projects_dir.iterdir(), key=lambda p: p.stat().st_mtime, reverse=True)[:3]:
    sessions.extend(sorted(project_dir.glob('*.jsonl'), key=lambda p: p.stat().st_mtime, reverse=True)[:5])

now = datetime.now().astimezone()
windows = {'5min': [], '15min': [], '30min': []}

for session_file in sessions[:10]:
    try:
        messages = []
        with open(session_file, 'r') as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    event = json.loads(line)
                    if event.get('type') == 'assistant' and 'message' in event:
                        msg = event['message']
                        if 'usage' in msg and 'timestamp' in event:
                            ts = datetime.fromisoformat(event['timestamp'].replace('Z', '+00:00'))
                            tokens = msg['usage'].get('input_tokens', 0) + msg['usage'].get('output_tokens', 0)
                            messages.append({'ts': ts, 'tokens': tokens})
                except:
                    continue

        # Calculate rates between consecutive messages
        for i in range(1, len(messages)):
            try:
                duration_ms = (messages[i]['ts'] - messages[i-1]['ts']).total_seconds() * 1000
                tokens = messages[i]['tokens']
                age = (now - messages[i]['ts']).total_seconds() / 60  # minutes ago

                # Only include fast responses (< 15s) - pure LLM processing without tool delays
                # Filter: 100ms-15s duration, significant tokens, rate < 20ms/token
                if 100 < duration_ms < 15000 and tokens > 200:
                    rate = duration_ms / tokens
                    # Cap at 20ms/token - anything higher is tool/network overhead
                    if rate < 20:
                        if age <= 5:
                            windows['5min'].append(rate)
                        if age <= 15:
                            windows['15min'].append(rate)
                        if age <= 30:
                            windows['30min'].append(rate)
            except:
                continue
    except:
        continue

# Use P25 (faster end) since we're saving INPUT tokens which process faster
def percentile(lst, p):
    if not lst:
        return None
    s = sorted(lst)
    idx = int(len(s) * p / 100)
    return s[min(idx, len(s)-1)]

rates = []
for w in ['5min', '15min', '30min']:
    # P25 gives us the faster, cleaner samples
    p = percentile(windows[w], 25)
    if p is not None:
        rates.append(p)

if rates:
    rate_low = min(rates)
    rate_high = max(rates)
    samples = sum(len(v) for v in windows.values())
    print(json.dumps({'rate_low': round(rate_low, 2), 'rate_high': round(rate_high, 2), 'samples': samples}))
else:
    # Fallback: documented input processing rate (~2ms/token)
    print(json.dumps({'rate_low': 1.5, 'rate_high': 3.0, 'samples': 0}))
PYEOF
)

    local rate_low=$(echo "$rate_data" | jq -r '.rate_low')
    local rate_high=$(echo "$rate_data" | jq -r '.rate_high')
    local rate_samples=$(echo "$rate_data" | jq -r '.samples')

    # Calculate time range from dynamic rates
    local time_low=$(awk "BEGIN {printf \"%.0f\", $tokens_saved * $rate_low / 1000}")
    local time_high=$(awk "BEGIN {printf \"%.0f\", $tokens_saved * $rate_high / 1000}")

    # Format time range compactly
    format_time_compact() {
        local sec=$1
        if [ "$sec" -ge 3600 ] 2>/dev/null; then
            awk "BEGIN {printf \"%.1fh\", $sec / 3600}"
        elif [ "$sec" -ge 60 ] 2>/dev/null; then
            awk "BEGIN {printf \"%.0fm\", $sec / 60}"
        else
            echo "${sec}s"
        fi
    }

    local time_display=""
    if [ "$tokens_saved" -gt 0 ] 2>/dev/null && [ "$time_high" -gt 0 ] 2>/dev/null; then
        local t_low=$(format_time_compact $time_low)
        local t_high=$(format_time_compact $time_high)
        if [ "$t_low" = "$t_high" ]; then
            time_display="‚ö°~${t_low}"
        else
            time_display="‚ö°${t_low}-${t_high}"
        fi
    fi

    # Header
    echo -e "${CYAN}${BOLD}aOa Activity${NC}                                                 Session"
    echo ""
    # Only show savings if we have REAL data (not fabricated)
    if [ "$tokens_saved" -gt 0 ] 2>/dev/null; then
        if [ -n "$time_display" ]; then
            echo -e "${BOLD}SAVINGS${NC}         ${GREEN}‚Üì${tokens_k}k tokens${NC} ${CYAN}${time_display}${NC} ${DIM}(rolling avg)${NC}"
        else
            echo -e "${BOLD}SAVINGS${NC}         ${GREEN}‚Üì${tokens_k}k tokens${NC}"
        fi
    else
        echo -e "${BOLD}SAVINGS${NC}         ${DIM}(no measured savings yet)${NC}"
    fi
    echo -e "${BOLD}PREDICTIONS${NC}     ${hit_pct_int}% accuracy (${hits} of ${evaluated} hits)"
    echo -e "${BOLD}HOW IT WORKS${NC}    ${CYAN}aOa finds exact locations${NC}, so Claude reads only what it needs"
    echo -e "                ${DIM}Time: rolling avg (5/15/30min) of input token processing${NC}"
    echo ""
    echo -e "${DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    echo ""
    echo -e "ACTION     SOURCE   ATTRIB       aOa IMPACT                TAGS                                                    TARGET"

    # Process records - extract file_size (baseline) and output_size (actual)
    # Skip records with no files (noise) - require at least one real file
    echo "$result" | jq -r --arg project_root "$(get_project_root)" '.records[] |
        select(.files | length > 0) |
        select(.files[0] != null and .files[0] != "") |
        {
            tool: .tool,
            files: (.files[0] // "unknown"),
            file_count: (.files | length),
            tags: (.tags[0:6] | join(" ")),
            file_size: (if (.file_sizes and .files[0]) then .file_sizes[.files[0]] else null end),
            output_size: .output_size
        } |
        # Use ASCII Unit Separator (0x1F) - designed for field separation, never in user input
        "\(.tool)\u001f\(.files)\u001f\(.tags)\u001f\(.file_size // 0)\u001f\(.output_size // 0)\u001f\(.file_count)"
    ' 2>/dev/null | while IFS=$'\x1f' read -r tool file tags file_size output_size file_count; do
        # Map tool to action and determine source
        local action="$tool"
        local source="Claude"

        case "$tool" in
            Bash)
                # Check for aOa commands - format: cmd:aoa:type:term:hits:time
                # Term may contain escaped colons (\:), so parse carefully
                if echo "$file" | grep -q "^cmd:aoa:"; then
                    source="aOa"
                    # Extract type (field 3)
                    local aoa_type=$(echo "$file" | cut -d: -f3)
                    # Map aOa command to display action
                    case "$aoa_type" in
                        grep|search|multi)  action="Search" ;;
                        egrep|pattern)      action="Search" ;;
                        find)               action="Find" ;;
                        tree)               action="Tree" ;;
                        locate)             action="Locate" ;;
                        head|tail|lines)    action="Read" ;;
                        hot)                action="Predict" ;;
                        touched)            action="Intent" ;;
                        focus)              action="Memory" ;;
                        predict)            action="Predict" ;;
                        outline)            action="Outline" ;;
                        *)                  action="Search" ;;
                    esac
                    # Extract hits:time from end (last 2 colon-separated fields)
                    local aoa_time=$(echo "$file" | rev | cut -d: -f1 | rev)
                    local aoa_hits=$(echo "$file" | rev | cut -d: -f2 | rev)
                    # Extract term: everything between field 3 and hits:time
                    # Remove "cmd:aoa:type:" prefix and ":hits:time" suffix
                    local aoa_term=$(echo "$file" | sed "s/^cmd:aoa:${aoa_type}://" | sed "s/:${aoa_hits}:${aoa_time}$//")
                    # URL-decode the term (handles all special chars: |, \, :, etc.)
                    aoa_term=$(python3 -c "from urllib.parse import unquote; print(unquote('$aoa_term'))" 2>/dev/null || echo "$aoa_term")
                    # Store for later use in attribution/impact
                    export AOA_SEARCH_TYPE="$aoa_type"
                    export AOA_SEARCH_HITS="$aoa_hits"
                    export AOA_SEARCH_TIME="$aoa_time"
                    # Store the full command for display (will be formatted at print time)
                    local display_term="${aoa_term:0:50}"
                    [ ${#aoa_term} -gt 50 ] && display_term="${display_term}..."
                    # Mark as aOa command for special formatting at print time
                    file="AOA_CMD:${display_term}"
                # Old format: cmd:aoa search term (space separated)
                elif echo "$file" | grep -q "^cmd:aoa "; then
                    action="Search"
                    source="aOa"
                    local aoa_term=$(echo "$file" | sed 's/^cmd:aoa [a-z]* //')
                    export AOA_SEARCH_TYPE="search"
                    export AOA_SEARCH_HITS=""
                    export AOA_SEARCH_TIME=""
                    file="\"${aoa_term}\""
                fi
                ;;
            Outline)
                source="aOa"
                ;;
            HaikuTag|Intent)
                action="Intent"
                source="aOa"
                ;;
            Predict)
                source="aOa"
                ;;
        esac

        # Calculate tokens from file size if available
        local actual base saved time_saved base_tokens

        # If we have file size, use it for more accurate baseline
        if [ "$file_size" -gt 0 ] 2>/dev/null; then
            # BASE = file size in bytes / 4 (Claude uses ~4 chars per token)
            base_tokens=$((file_size / 4))

            # Format with k suffix if > 1000
            if [ $base_tokens -ge 1000 ]; then
                local base_k=$(awk "BEGIN {printf \"%.1f\", $base_tokens/1000}")
                base="${base_k}k"
            else
                base="$base_tokens"
            fi
        else
            # Fallback to defaults if no file size
            base_tokens=0
            base="?"
        fi

        # ACTUAL and SAVED - only show REAL metrics, never fabricate
        case "$action" in
            Grep|Glob)
                # Grep/Glob bypass aOa - warn user to use aoa search instead
                actual="SLOW"
                saved="SLOW"
                time_saved="SLOW"
                ;;
            Outline)
                # AI-generated symbol-level tags - enrichment, not reduction
                actual="AI"
                saved="AI"
                time_saved="-"
                ;;
            HaikuTag)
                # AI-generated tags - enrichment, not reduction
                actual="AI"
                saved="AI"
                time_saved="-"
                ;;
            *)
                # Check if we have REAL output_size data
                if [ "$output_size" -gt 0 ] 2>/dev/null; then
                    # REAL data: calculate actual tokens from output_size
                    local actual_tokens=$((output_size / 4))

                    # Format actual with k suffix if > 1000
                    if [ $actual_tokens -ge 1000 ]; then
                        local actual_k=$(awk "BEGIN {printf \"%.1f\", $actual_tokens/1000}")
                        actual="${actual_k}k"
                    else
                        actual="$actual_tokens"
                    fi

                    # Calculate savings if we have baseline
                    if [ $base_tokens -gt 0 ]; then
                        local saved_tokens=$((base_tokens - actual_tokens))
                        if [ $saved_tokens -gt 0 ]; then
                            if [ $saved_tokens -ge 1000 ]; then
                                local saved_k=$(awk "BEGIN {printf \"%.1f\", $saved_tokens/1000}")
                                saved="${saved_k}k"
                            else
                                saved="$saved_tokens"
                            fi
                        else
                            saved="0"
                        fi
                    else
                        saved="-"
                    fi
                    time_saved="-"
                else
                    # No output_size captured yet - be honest
                    actual="-"
                    saved="-"
                    time_saved="-"
                fi
                ;;
        esac

        # Format saved with k suffix if numeric and > 1000
        if [[ "$saved" =~ ^[0-9]+$ ]] && [ "$saved" -ge 1000 ]; then
            local saved_k=$(awk "BEGIN {printf \"%.1f\", $saved/1000}")
            saved="${saved_k}k"
        fi

        # Format file path (project-relative)
        local target=$(echo "$file" | sed "s|$(get_project_root)/||" 2>/dev/null || echo "$file")

        # Calculate attribution and impact
        local impact attribution

        # Special handling for aOa native operations - tell meaningful stories
        if [ "$action" = "Predict" ]; then
            # Extract confidence from tags (format: @XX%)
            local confidence=$(echo "$tags" | grep -oE '@[0-9]+%' | head -1 | tr -d '@')
            if [ -n "$confidence" ]; then
                attribution="${CYAN}${confidence}${NC} conf"
                # Remove confidence from tags to avoid duplication
                tags=$(echo "$tags" | sed 's/@[0-9]*%//' | sed 's/  / /g' | xargs)
            else
                attribution="${CYAN}predicted${NC}"
            fi
            # Show predicted file count
            if [ "$file_count" -gt 1 ] 2>/dev/null; then
                impact="${CYAN}${file_count} files${NC} suggested"
            else
                impact="${CYAN}1 file${NC} suggested"
            fi
        elif [ "$action" = "Intent" ]; then
            # Haiku semantic tagging
            attribution="${CYAN}semantic${NC}"
            local tag_count=$(echo "$tags" | wc -w)
            impact="${CYAN}${tag_count} tags${NC} generated"
        elif [ "$action" = "Outline" ]; then
            # Symbol-level enrichment
            attribution="${CYAN}symbols${NC}"
            impact="${CYAN}enriched${NC}"
        elif [ "$action" = "Search" ] || [ "$action" = "Find" ] || [ "$action" = "Locate" ] || [ "$action" = "Tree" ]; then
            # aOa search/discovery operations - show command type as attribution
            # Detect pattern search: if grep took >5ms, it was routed to egrep (pattern search)
            local search_type="$AOA_SEARCH_TYPE"
            if [[ "$search_type" == "grep" ]] && [[ -n "$AOA_SEARCH_TIME" ]]; then
                local time_int=$(printf "%.0f" "$AOA_SEARCH_TIME" 2>/dev/null || echo "0")
                [ "$time_int" -gt 5 ] && search_type="egrep"
            fi
            case "$search_type" in
                grep|search)  attribution="${CYAN}symbol${NC}" ;;
                egrep|pattern) attribution="${CYAN}pattern${NC}" ;;
                multi)        attribution="${CYAN}multi${NC}" ;;
                find)         attribution="${CYAN}files${NC}" ;;
                tree)         attribution="${CYAN}structure${NC}" ;;
                locate)       attribution="${CYAN}filename${NC}" ;;
                head|tail|lines) attribution="${CYAN}content${NC}" ;;
                hot)          attribution="${CYAN}frequency${NC}" ;;
                touched)      attribution="${CYAN}session${NC}" ;;
                focus)        attribution="${CYAN}context${NC}" ;;
                predict)      attribution="${CYAN}predicted${NC}" ;;
                *)            attribution="${CYAN}symbol${NC}" ;;
            esac
            # Truncate time to 2 decimal places
            local time_display=$(printf "%.2f" "$AOA_SEARCH_TIME" 2>/dev/null || echo "$AOA_SEARCH_TIME")
            # Impact shows hits and timing
            if [ -n "$AOA_SEARCH_HITS" ] && [ "$AOA_SEARCH_HITS" != "0" ]; then
                impact="${CYAN}${BOLD}${AOA_SEARCH_HITS} hits${NC} ${DIM}‚îÇ${NC} ${GREEN}${time_display}ms${NC}"
            else
                impact="${DIM}0 hits${NC}"
            fi
        # Determine attribution based on source and savings
        # aOa brand color is CYAN (consistent with status line)
        elif [ "$source" = "aOa" ]; then
            attribution="${CYAN}${BOLD}aOa${NC}"
        else
            attribution="-"  # Default, may be upgraded to "aOa guided" below
        fi

        if [ "$action" = "Predict" ] || [ "$action" = "Intent" ] || [ "$action" = "Outline" ] || [ "$action" = "Search" ] || [ "$action" = "Find" ] || [ "$action" = "Locate" ] || [ "$action" = "Tree" ] || [ "$action" = "Memory" ]; then
            : # Impact already set above for aOa native operations
        elif [ "$saved" = "-" ]; then
            impact="-"
        elif [ "$saved" = "SLOW" ]; then
            # Glob/Grep warning - short to fit 25-char column
            impact="${YELLOW}slow${NC} ${DIM}‚Üí aoa grep${NC}"
        elif [ "$saved" = "AI" ]; then
            if [ "$action" = "Outline" ]; then
                impact="${CYAN}symbol tags${NC}"
            else
                impact="${CYAN}semantic tags${NC}"
            fi
        else
            # Check if we have REAL savings data (both baseline AND actual output)
            if [ "$output_size" -gt 0 ] 2>/dev/null && [ "$base_tokens" -gt 0 ]; then
                # REAL measured savings - calculate percentage
                local actual_tokens=$((output_size / 4))
                local saved_tokens=$((base_tokens - actual_tokens))
                if [ $saved_tokens -gt 0 ]; then
                    local pct=$((saved_tokens * 100 / base_tokens))
                    # aOa-enabled: significant reduction means aOa guided Claude to read only what it needed
                    if [ $pct -ge 50 ]; then
                        # High savings = aOa guided (this is the value prop!)
                        # CYAN "aOa" (brand color) + GREEN "guided"
                        attribution="${CYAN}${BOLD}aOa${NC} ${GREEN}guided${NC}"
                        impact="${GREEN}${BOLD}‚Üì${pct}%${NC} (${base} ‚Üí ${actual})"
                    else
                        # Modest savings
                        impact="${GREEN}${pct}%${NC} (${base} ‚Üí ${actual})"
                    fi
                else
                    # Full file read - standard Claude operation
                    impact="-"
                fi
            else
                # No measurement data - standard operation
                impact="-"
            fi
        fi

        # Truncate tags to 55 chars (room for 5-6 tags typically)
        if [ ${#tags} -gt 55 ]; then
            tags="${tags:0:52}..."
        fi

        # Color the source if it's aOa (brand consistency)
        local source_display
        if [ "$source" = "aOa" ]; then
            source_display="${CYAN}${BOLD}aOa${NC}"
        else
            source_display="$source"
        fi

        # Manual padding for color code compatibility
        # Strip ANSI codes to get visible length for source
        local source_visible=$(echo -e "$source_display" | sed 's/\x1b\[[0-9;]*m//g')
        local source_len=${#source_visible}
        local source_pad=$((8 - source_len))

        # Strip ANSI codes to get visible length for attribution
        local attrib_visible=$(echo -e "$attribution" | sed 's/\x1b\[[0-9;]*m//g')
        local attrib_len=${#attrib_visible}
        local attrib_pad=$((12 - attrib_len))

        # Strip ANSI codes for impact
        local impact_visible=$(echo -e "$impact" | sed 's/\x1b\[[0-9;]*m//g')
        local impact_len=${#impact_visible}
        local impact_pad=$((25 - impact_len))

        printf "%-10s " "$action"
        echo -ne "$source_display"
        [ $source_pad -gt 0 ] && printf "%${source_pad}s" ""
        echo -ne " $attribution"
        [ $attrib_pad -gt 0 ] && printf "%${attrib_pad}s" ""
        echo -ne " $impact"
        [ $impact_pad -gt 0 ] && printf "%${impact_pad}s" ""
        printf " %-55s " "$tags"
        # Format aOa commands with branding: aOa in CYAN, command in GREEN
        if [[ "$target" == AOA_CMD:* ]]; then
            local aoa_display="${target#AOA_CMD:}"
            # Parse: aoa <cmd> [rest]
            if [[ "$aoa_display" =~ ^aoa\ +([a-z]+)(\ +.*)? ]]; then
                local cmd="${BASH_REMATCH[1]}"
                local rest="${BASH_REMATCH[2]:-}"
                echo -e "${CYAN}aOa${NC} ${GREEN}${cmd}${NC}${rest}"
            else
                echo -e "${CYAN}aOa${NC} ${aoa_display#aoa }"
            fi
        else
            echo "$target"
        fi
    done

    echo ""
    echo -e "${DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    echo ""
    echo -e "${DIM}${limit} of ${total} operations.  Use: watch -n 2 aoa intent${NC}"
}

cmd_intent_tags() {
    local project_id=$(get_project_id)
    local result=$(curl -s "${INDEX_URL}/intent/tags?project_id=${project_id}")

    echo -e "${BOLD}Intent Tags${NC}"
    echo ""

    echo "$result" | jq -r '.tags[] | "  \(.tag) (\(.count) files)"' 2>/dev/null || echo "  (no tags yet)"
}

cmd_intent_files() {
    local tag="$1"
    local project_id=$(get_project_id)

    if [ -z "$tag" ]; then
        echo "Usage: aoa intent files <tag>"
        echo "Example: aoa intent files authentication"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/intent/files?tag=${tag}&project_id=${project_id}")

    local actual_tag=$(echo "$result" | jq -r '.tag')
    echo -e "${BOLD}Files for ${actual_tag}${NC}"
    echo ""

    echo "$result" | jq -r '.files[]' 2>/dev/null || echo "  (no files)"
}

cmd_intent_file() {
    local path="$1"
    local project_id=$(get_project_id)

    if [ -z "$path" ]; then
        echo "Usage: aoa intent file <path>"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/intent/file?path=${path}&project_id=${project_id}")

    echo -e "${BOLD}Tags for ${path}${NC}"
    echo ""

    echo "$result" | jq -r '.tags[]' 2>/dev/null || echo "  (no tags)"
}

cmd_intent_stats() {
    local project_id=$(get_project_id)

    # Get metrics
    local metrics=$(curl -s "${INDEX_URL}/metrics?project_id=${project_id}")
    local hit_pct=$(echo "$metrics" | jq -r '.rolling.hit_at_5_pct // 0')
    local evaluated=$(echo "$metrics" | jq -r '.rolling.evaluated // 0')
    local hits=$(echo "$metrics" | jq -r '.rolling.hits // 0')
    local tokens_saved=$(echo "$metrics" | jq -r '.savings.tokens // 0')

    # Get intent stats
    local stats=$(curl -s "${INDEX_URL}/intent/stats?project_id=${project_id}")
    local total=$(echo "$stats" | jq -r '.total_records // 0')
    local unique_tags=$(echo "$stats" | jq -r '.unique_tags // 0')
    local unique_files=$(echo "$stats" | jq -r '.unique_files // 0')

    local hit_pct_int=$(printf "%.0f" "$hit_pct")

    # Header
    echo -e "${CYAN}${BOLD}aOa Session Statistics${NC}                                      ${total} operations"
    echo ""
    echo -e "${BOLD}WHAT WE TRACK (REAL DATA)${NC}"
    echo -e "  Predictions:      ${GREEN}${hit_pct_int}% accuracy${NC} (${hits} of ${evaluated} hits)"
    echo -e "  Operations:       ${total}"
    echo -e "  Unique files:     ${unique_files}"
    echo -e "  Unique tags:      ${unique_tags}"
    echo ""
    echo -e "${BOLD}TOKEN SAVINGS${NC}"
    if [ "$tokens_saved" -gt 0 ] 2>/dev/null; then
        local tokens_k=$(awk "BEGIN {printf \"%.1f\", $tokens_saved/1000}")
        echo -e "  Measured:         ${GREEN}‚Üì${tokens_k}k tokens${NC}"
    else
        echo -e "  ${DIM}Not yet measured - requires capturing actual output tokens${NC}"
        echo -e "  ${DIM}Baseline (file sizes) is captured; actual output capture coming soon${NC}"
    fi
    echo ""
    echo -e "${DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    echo ""
    echo -e "${DIM}Run 'aoa intent' to see recent activity with per-operation details${NC}"
}

cmd_intent_store() {
    # Store AI-generated intent tags
    # Usage: aoa intent store "#tag1 #tag2 #tag3" [file1] [file2] ...
    local tags_str="$1"
    shift || true

    if [ -z "$tags_str" ]; then
        echo -e "${RED}Usage: aoa intent store \"#tag1 #tag2\" [file1] [file2]${NC}"
        echo -e "${DIM}Example: aoa intent store \"#auth #validation\" src/auth.py${NC}"
        return 1
    fi

    local project_id=$(get_project_id)
    local session_id="${AOA_SESSION_ID:-$(date +%Y%m%d)}"

    # Parse tags (space or comma separated)
    local tags_json=$(echo "$tags_str" | tr ',' ' ' | xargs -n1 | sed 's/^#*/#/' | jq -R . | jq -s .)

    # Collect files (remaining args, or use current context files)
    local files_json="[]"
    if [ $# -gt 0 ]; then
        files_json=$(printf '%s\n' "$@" | jq -R . | jq -s .)
    fi

    # Build and send request
    local payload=$(jq -n \
        --arg sid "$session_id" \
        --arg pid "$project_id" \
        --argjson tags "$tags_json" \
        --argjson files "$files_json" \
        '{session_id: $sid, project_id: $pid, tool: "Intent", tags: $tags, files: $files}')

    local result=$(curl -s -X POST "${INDEX_URL}/intent" \
        -H "Content-Type: application/json" \
        -d "$payload")

    if echo "$result" | jq -e '.success' > /dev/null 2>&1; then
        local tag_count=$(echo "$tags_json" | jq 'length')
        echo -e "${GREEN}‚úì${NC} Stored ${tag_count} tags"
    else
        echo -e "${RED}‚úó${NC} Failed to store tags"
        return 1
    fi
}

cmd_rate() {
    # Show token savings with estimated time savings
    # Uses conservative LLM processing rates based on documented performance

    echo -e "${CYAN}${BOLD}Time Savings Estimation${NC}"
    echo ""

    # Get current token savings from intent stats
    local project_id=$(get_project_id)
    local metrics=$(curl -s "${INDEX_URL}/metrics?project_id=${project_id}")
    local tokens_saved=$(echo "$metrics" | jq -r '.savings.tokens // 0')
    local tokens_k=$(awk "BEGIN {printf \"%.1f\", $tokens_saved/1000}")

    echo -e "${BOLD}YOUR TOKEN SAVINGS${NC}"
    if [ "$tokens_saved" -gt 0 ] 2>/dev/null; then
        echo -e "  Measured:         ${GREEN}‚Üì${tokens_k}k tokens${NC}"
    else
        echo -e "  ${DIM}(no measured savings yet)${NC}"
    fi
    echo ""

    echo -e "${BOLD}TIME SAVINGS MODEL${NC}"
    echo -e "  ${DIM}LLMs process tokens at documented rates:${NC}"
    echo -e "    Input tokens:   ~100-500 tokens/second"
    echo -e "    Output tokens:  ~20-100 tokens/second"
    echo ""
    echo -e "  ${BOLD}Conservative estimate:${NC} 5-10ms per token (combined)"
    echo ""

    echo -e "${DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    echo ""

    if [ "$tokens_saved" -gt 0 ] 2>/dev/null; then
        # Calculate time savings range
        local time_low=$(awk "BEGIN {printf \"%.1f\", $tokens_saved * 5 / 1000}")   # 5ms/token
        local time_high=$(awk "BEGIN {printf \"%.1f\", $tokens_saved * 10 / 1000}") # 10ms/token

        echo -e "${BOLD}ESTIMATED TIME SAVINGS${NC}"
        echo -e "  Low estimate:     ${CYAN}~${time_low}s${NC} (at 5ms/token)"
        echo -e "  High estimate:    ${CYAN}~${time_high}s${NC} (at 10ms/token)"
        echo ""

        # Additional context for large savings
        if [ "$tokens_saved" -gt 100000 ]; then
            local mins_low=$(awk "BEGIN {printf \"%.1f\", $time_low / 60}")
            local mins_high=$(awk "BEGIN {printf \"%.1f\", $time_high / 60}")
            echo -e "  That's ${GREEN}${mins_low}-${mins_high} minutes${NC} of LLM processing avoided"
            echo ""
        fi

        echo -e "${DIM}Plus search speed: aOa search (~5ms) vs grep (~2-3 seconds)${NC}"
    else
        echo -e "${BOLD}EXAMPLE${NC}"
        echo -e "  If you save 22k tokens:"
        echo -e "    Low:  22k √ó 5ms  = ${CYAN}~110s${NC}"
        echo -e "    High: 22k √ó 10ms = ${CYAN}~220s${NC}"
    fi
    echo ""
    echo -e "${DIM}Note: Estimates based on typical Claude API processing speeds${NC}"
}

# =============================================================================
# Utility Commands
# =============================================================================

cmd_info() {
    echo -e "${CYAN}${BOLD}‚ö° aOa Indexing Configuration${NC}"
    echo ""

    # Show aOa home
    echo -e "${BOLD}aOa Installation:${NC}"
    echo -e "  Home: ${AOA_HOME}"
    echo -e "  Data: ${AOA_DATA}"
    echo ""

    # Read from .env file if it exists (root directory, where docker-compose reads it)
    local env_file="${AOA_HOME}/.env"
    local projects_root="${HOME}"
    local gateway_port="8080"

    if [ -f "$env_file" ]; then
        projects_root=$(grep "^PROJECTS_ROOT=" "$env_file" 2>/dev/null | cut -d'=' -f2 || echo "$HOME")
        gateway_port=$(grep "^GATEWAY_PORT=" "$env_file" 2>/dev/null | cut -d'=' -f2 || echo "8080")
    fi

    # Show Docker configuration from .env
    echo -e "${BOLD}Docker Configuration:${NC} ${DIM}(from .env)${NC}"
    echo -e "  PROJECTS_ROOT:   ${projects_root} ‚Üí /userhome"
    echo -e "  GATEWAY_PORT:    ${gateway_port}"
    echo -e "  Claude sessions: ${projects_root}/.claude ${DIM}(auto-derived)${NC}"
    echo ""
    echo -e "  ${DIM}Edit .env in aOa root to change, then restart Docker${NC}"
    echo ""

    # Show registered projects
    echo -e "${BOLD}Registered Projects:${NC}"
    local projects_file="${AOA_DATA}/projects.json"
    if [ -f "$projects_file" ] && [ "$(jq 'length' "$projects_file" 2>/dev/null)" != "0" ]; then
        jq -r '.[] | "  [\(.id | .[0:8])] \(.name) ‚Üí \(.path)"' "$projects_file" 2>/dev/null
    else
        echo -e "  ${DIM}(none - run 'aoa init' in a project)${NC}"
    fi
    echo ""

    # Show current project context
    local project_root=$(get_project_root)
    local project_id=$(get_project_id)
    if [ -n "$project_root" ]; then
        echo -e "${BOLD}Current Project:${NC}"
        echo -e "  Root: ${project_root}"
        echo -e "  ID:   ${project_id:-not initialized}"

        # Check if initialized
        if [ -z "$project_id" ]; then
            echo -e "  ${YELLOW}‚Üí Run 'aoa init' to enable aOa for this project${NC}"
        fi
    else
        echo -e "${BOLD}Current Project:${NC}"
        echo -e "  ${DIM}Not in a git repository${NC}"
    fi
    echo ""

    # Show what gets indexed
    echo -e "${BOLD}What Gets Indexed:${NC}"
    echo -e "  ‚úì Files in registered project roots"
    echo -e "  ‚úì Knowledge repos (repos/ directory)"
    echo -e "  ‚úì Claude session history (~/.claude)"
    echo ""
    echo -e "${BOLD}What Is Skipped:${NC}"
    echo -e "  ‚úó node_modules, .git, __pycache__, dist, build, etc."
    echo -e "  ‚úó Files outside registered projects"
    echo -e "  ‚úó Unrecognized file extensions"
    echo ""
    echo -e "${DIM}See: .aoa/config.json for full configuration${NC}"
}

cmd_services() {
    echo -e "${CYAN}${BOLD}"
    cat << 'EOF'
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                         aOa Attack Map                               ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                                      ‚ïë
‚ïë  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚ïë
‚ïë  ‚îÇ                     GATEWAY (:8080)                         ‚îÇ    ‚ïë
‚ïë  ‚îÇ              Single entry point for all angles              ‚îÇ    ‚ïë
‚ïë  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚ïë
‚ïë                              ‚îÇ                                       ‚ïë
‚ïë          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚ïë
‚ïë          ‚ñº                   ‚ñº                   ‚ñº                  ‚ïë
‚ïë  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚ïë
‚ïë  ‚îÇ    INDEX      ‚îÇ   ‚îÇ    STATUS     ‚îÇ   ‚îÇ   GIT-PROXY   ‚îÇ         ‚ïë
‚ïë  ‚îÇ    :9999      ‚îÇ   ‚îÇ    :9998      ‚îÇ   ‚îÇ    :9997      ‚îÇ         ‚ïë
‚ïë  ‚îÇ               ‚îÇ   ‚îÇ               ‚îÇ   ‚îÇ               ‚îÇ         ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Symbol      ‚îÇ   ‚îÇ ‚Ä¢ Sessions    ‚îÇ   ‚îÇ ‚Ä¢ Clone repos ‚îÇ         ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Ranking     ‚îÇ   ‚îÇ ‚Ä¢ History     ‚îÇ   ‚îÇ ‚Ä¢ Allowlist   ‚îÇ         ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Intent      ‚îÇ   ‚îÇ ‚Ä¢ Metrics     ‚îÇ   ‚îÇ               ‚îÇ         ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Memory      ‚îÇ   ‚îÇ               ‚îÇ   ‚îÇ               ‚îÇ         ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Tuner       ‚îÇ   ‚îÇ               ‚îÇ   ‚îÇ               ‚îÇ         ‚ïë
‚ïë  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚ïë
‚ïë          ‚îÇ                                                          ‚ïë
‚ïë          ‚ñº                                                          ‚ïë
‚ïë  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                                  ‚ïë
‚ïë  ‚îÇ    REDIS      ‚îÇ                                                  ‚ïë
‚ïë  ‚îÇ    :6379      ‚îÇ                                                  ‚ïë
‚ïë  ‚îÇ               ‚îÇ                                                  ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Scores      ‚îÇ                                                  ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Transitions ‚îÇ                                                  ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Predictions ‚îÇ                                                  ‚ïë
‚ïë  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                                  ‚ïë
‚ïë                                                                      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  THE FIVE ANGLES                                                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                                      ‚ïë
‚ïë  ‚ö° SYMBOL         O(1) symbol lookup across codebase                ‚ïë
‚ïë     aoa search <term>                                                ‚ïë
‚ïë                                                                      ‚ïë
‚ïë  üéØ INTENT         Track tool calls, extract behavior patterns       ‚ïë
‚ïë     aoa intent recent                                                ‚ïë
‚ïë                                                                      ‚ïë
‚ïë  üß† STRIKE         Predictive context, dynamic working memory        ‚ïë
‚ïë     aoa context "fix auth bug"                                       ‚ïë
‚ïë                                                                      ‚ïë
‚ïë  üìä SIGNAL         Multi-term ranking, pattern matching              ‚ïë
‚ïë     aoa multi auth,session                                           ‚ïë
‚ïë                                                                      ‚ïë
‚ïë  üìÅ INTEL          External reference repos, isolated search         ‚ïë
‚ïë     aoa repo <name> search <term>                                    ‚ïë
‚ïë                                                                      ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
    echo -e "${NC}"

    # Show live stats
    echo -e "${BOLD}Live Status${NC}"
    echo ""

    # Health check
    local index_ok=false
    local status_ok=false
    local redis_ok=false

    curl -s --connect-timeout 1 "http://localhost:8080/health" > /dev/null 2>&1 && index_ok=true
    curl -s --connect-timeout 1 "http://localhost:8080/status" > /dev/null 2>&1 && status_ok=true

    # Check Redis (works in both unified and compose modes)
    if docker exec aoa redis-cli ping > /dev/null 2>&1; then
        redis_ok=true
    elif docker exec aoa-redis-1 redis-cli ping > /dev/null 2>&1; then
        redis_ok=true
    fi

    if $index_ok; then
        echo -e "  Index:  ${GREEN}‚úì${NC} Running"
    else
        echo -e "  Index:  ${RED}‚úó${NC} Not responding"
    fi

    if $status_ok; then
        echo -e "  Status: ${GREEN}‚úì${NC} Running"
    else
        echo -e "  Status: ${RED}‚úó${NC} Not responding"
    fi

    if $redis_ok; then
        echo -e "  Redis:  ${GREEN}‚úì${NC} Connected"
    else
        echo -e "  Redis:  ${RED}‚úó${NC} Not connected"
    fi

    echo ""

    # Quick stats
    local memory_result=$(curl -s "http://localhost:8080/memory?format=compact" 2>/dev/null)
    if [ -n "$memory_result" ]; then
        local files=$(echo "$memory_result" | jq -r '.files_analyzed' 2>/dev/null)
        local ms=$(echo "$memory_result" | jq -r '.ms' 2>/dev/null)
        echo -e "  Memory: ${files} active files, ${GREEN}${ms}ms${NC} latency"
    fi

    local health_result=$(curl -s "http://localhost:8080/health" 2>/dev/null)
    if [ -n "$health_result" ]; then
        local symbols=$(echo "$health_result" | jq -r '.local.symbols' 2>/dev/null)
        local idx_files=$(echo "$health_result" | jq -r '.local.files' 2>/dev/null)
        echo -e "  Index:  ${idx_files} files, ${symbols} symbols"
    fi
}

cmd_memory() {
    local format="${1:-prose}"

    case "$format" in
        -c|--compact|compact)
            format="compact"
            ;;
        -s|--structured|structured|json)
            format="structured"
            ;;
        -p|--prose|prose|*)
            format="prose"
            ;;
    esac

    local result=$(curl -s "http://localhost:8080/memory?format=${format}")

    if [ "$format" = "structured" ]; then
        echo "$result" | jq .
    else
        local memory=$(echo "$result" | jq -r '.memory')
        local ms=$(echo "$result" | jq -r '.ms')
        local files=$(echo "$result" | jq -r '.files_analyzed')

        echo -e "${CYAN}${BOLD}‚ö° aOa Working Memory${NC} ${DIM}‚îÇ${NC} ${files} files ${DIM}‚îÇ${NC} ${GREEN}${ms}ms${NC}"
        echo ""
        echo "$memory"
    fi
}

cmd_health() {
    local project_root=$(get_project_root)
    local all_ok=true
    local warnings=0

    echo -e "${BOLD}aOa Health Check${NC}"
    echo -e "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo ""

    # =========================================================================
    # SERVICES
    # =========================================================================
    echo -e "${BOLD}Services${NC}"

    # Check Docker
    echo -n "  Docker:        "
    if docker ps --filter "name=aoa" --format "{{.Names}}" 2>/dev/null | grep -q "aoa"; then
        echo -e "${GREEN}‚úì${NC} Container running"
    else
        echo -e "${RED}‚úó${NC} Container not found"
        all_ok=false
    fi

    # Check Index service
    echo -n "  Index:         "
    local idx_health=""
    if curl -s --connect-timeout 2 "${INDEX_URL}/health" > /dev/null 2>&1; then
        idx_health=$(curl -s "${INDEX_URL}/health")
        local mode=$(echo "$idx_health" | jq -r '.mode // "legacy"')
        if [ "$mode" = "global" ]; then
            local project_count=$(echo "$idx_health" | jq '.projects | length // 0')
            echo -e "${GREEN}‚úì${NC} Running (${project_count} project(s))"
        else
            local local_files=$(echo "$idx_health" | jq -r '.local.files // 0')
            local local_symbols=$(echo "$idx_health" | jq -r '.local.symbols // 0')
            echo -e "${GREEN}‚úì${NC} ${local_files} files, ${local_symbols} symbols"
        fi
    else
        echo -e "${RED}‚úó${NC} Not responding"
        all_ok=false
    fi

    # Check Redis
    echo -n "  Redis:         "
    if docker exec aoa redis-cli ping > /dev/null 2>&1; then
        echo -e "${GREEN}‚úì${NC} Connected"
    elif docker exec aoa-redis-1 redis-cli ping > /dev/null 2>&1; then
        echo -e "${GREEN}‚úì${NC} Connected"
    else
        echo -e "${YELLOW}!${NC} Not connected ${DIM}(predictions disabled)${NC}"
        warnings=$((warnings + 1))
    fi

    echo ""

    # =========================================================================
    # PROJECT CONFIGURATION
    # =========================================================================
    echo -e "${BOLD}Project Configuration${NC}"

    # Check if initialized
    echo -n "  Initialized:   "
    if [ -f "$project_root/.aoa/home.json" ]; then
        local project_id=$(jq -r '.project_id // "none"' "$project_root/.aoa/home.json" 2>/dev/null)
        echo -e "${GREEN}‚úì${NC} ${DIM}${project_id:0:8}...${NC}"
    else
        echo -e "${RED}‚úó${NC} Not initialized ${DIM}(run 'aoa init')${NC}"
        all_ok=false
    fi

    # Check hooks (essential: intent-capture + status-line)
    echo -n "  Hooks:         "
    local hook_count=0
    [ -f "$project_root/.claude/hooks/aoa-intent-capture.py" ] && hook_count=$((hook_count + 1))
    [ -f "$project_root/.claude/hooks/aoa-status-line.sh" ] && hook_count=$((hook_count + 1))

    if [ "$hook_count" -eq 2 ]; then
        echo -e "${GREEN}‚úì${NC} Essential hooks installed"
    elif [ "$hook_count" -gt 0 ]; then
        echo -e "${YELLOW}!${NC} ${hook_count}/2 essential hooks ${DIM}(partial)${NC}"
        warnings=$((warnings + 1))
    else
        echo -e "${RED}‚úó${NC} No hooks found"
        all_ok=false
    fi

    # Check CLAUDE.md
    echo -n "  CLAUDE.md:     "
    if [ -f "$project_root/CLAUDE.md" ]; then
        if grep -q "aoa search" "$project_root/CLAUDE.md" 2>/dev/null; then
            echo -e "${GREEN}‚úì${NC} Present with aOa instructions"
        else
            echo -e "${YELLOW}!${NC} Present ${DIM}(missing aOa instructions)${NC}"
            warnings=$((warnings + 1))
        fi
    else
        echo -e "${YELLOW}!${NC} Not found ${DIM}(optional)${NC}"
        warnings=$((warnings + 1))
    fi

    echo ""

    # =========================================================================
    # FUNCTIONALITY
    # =========================================================================
    echo -e "${BOLD}Functionality${NC}"

    # Test search
    echo -n "  Search:        "
    local search_result=$(curl -s --connect-timeout 2 "${INDEX_URL}/symbol?q=test" 2>/dev/null)
    if [ -n "$search_result" ]; then
        local ms=$(echo "$search_result" | jq -r '.ms // "?"')
        echo -e "${GREEN}‚úì${NC} Working ${DIM}(${ms}ms)${NC}"
    else
        echo -e "${RED}‚úó${NC} Not working"
        all_ok=false
    fi

    # Check intent capture
    echo -n "  Intent:        "
    local intent_result=$(curl -s --connect-timeout 2 "${INDEX_URL}/intent/recent?limit=1" 2>/dev/null)
    if [ -n "$intent_result" ]; then
        local total=$(echo "$intent_result" | jq -r '.stats.total_records // 0')
        local tags=$(echo "$intent_result" | jq -r '.stats.unique_tags // 0')
        echo -e "${GREEN}‚úì${NC} ${total} recorded, ${tags} tags"
    else
        echo -e "${YELLOW}!${NC} No data ${DIM}(fresh install)${NC}"
        warnings=$((warnings + 1))
    fi

    # Check semantic compression (outline angle)
    echo -n "  Outline:       "
    if docker exec aoa python3 -c "import tree_sitter" > /dev/null 2>&1 || \
       docker exec aoa-index-1 python3 -c "import tree_sitter" > /dev/null 2>&1; then
        echo -e "${GREEN}‚úì${NC} Semantic compression ready"
    else
        echo -e "${YELLOW}!${NC} Semantic compression unavailable"
        warnings=$((warnings + 1))
    fi

    echo ""

    # =========================================================================
    # SUMMARY
    # =========================================================================
    echo -e "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    if $all_ok && [ "$warnings" -eq 0 ]; then
        echo -e "Status: ${GREEN}‚úì All systems operational${NC}"
    elif $all_ok; then
        echo -e "Status: ${YELLOW}! Operational with ${warnings} warning(s)${NC}"
    else
        echo -e "Status: ${RED}‚úó Issues detected${NC}"
        echo -e "${DIM}Run 'aoa init' to configure this project${NC}"
    fi
}

# Infer tags from symbol name (free pattern-based tagging)
infer_tags_from_name() {
    local name="$1"
    local kind="$2"
    local tags=()

    # Convert camelCase/PascalCase to words
    local words=$(echo "$name" | sed 's/\([a-z]\)\([A-Z]\)/\1 \2/g' | sed 's/_/ /g' | tr '[:upper:]' '[:lower:]')

    # Common action verbs ‚Üí tags
    [[ "$words" =~ ^(get|fetch|load|read) ]] && tags+=("#read")
    [[ "$words" =~ ^(set|save|write|store|update|put) ]] && tags+=("#write")
    [[ "$words" =~ ^(delete|remove|clear) ]] && tags+=("#delete")
    [[ "$words" =~ ^(create|add|insert|new|make|build) ]] && tags+=("#create")
    [[ "$words" =~ ^(handle|process|on) ]] && tags+=("#handler")
    [[ "$words" =~ ^(validate|check|verify|is|has|can) ]] && tags+=("#validation")
    [[ "$words" =~ ^(parse|extract|convert|transform) ]] && tags+=("#transform")
    [[ "$words" =~ ^(init|setup|configure|start|boot) ]] && tags+=("#init")
    [[ "$words" =~ ^test ]] && tags+=("#test")

    # Domain keywords ‚Üí tags
    [[ "$words" =~ auth ]] && tags+=("#auth")
    [[ "$words" =~ user ]] && tags+=("#user")
    [[ "$words" =~ login|logout|session ]] && tags+=("#session")
    [[ "$words" =~ token|jwt|oauth ]] && tags+=("#token")
    [[ "$words" =~ api|endpoint|route ]] && tags+=("#api")
    [[ "$words" =~ database|db|sql|query ]] && tags+=("#database")
    [[ "$words" =~ cache|redis ]] && tags+=("#cache")
    [[ "$words" =~ file|path|dir ]] && tags+=("#filesystem")
    [[ "$words" =~ config|setting|option ]] && tags+=("#config")
    [[ "$words" =~ error|exception|fail ]] && tags+=("#error")
    [[ "$words" =~ log|debug|trace ]] && tags+=("#logging")
    [[ "$words" =~ http|request|response ]] && tags+=("#http")
    [[ "$words" =~ json|xml|yaml ]] && tags+=("#serialization")
    [[ "$words" =~ encrypt|decrypt|hash|secret ]] && tags+=("#security")
    [[ "$words" =~ search|find|filter|sort ]] && tags+=("#search")
    [[ "$words" =~ render|display|view|template ]] && tags+=("#render")
    [[ "$words" =~ email|mail|send|notify ]] && tags+=("#notification")
    [[ "$words" =~ queue|job|task|worker ]] && tags+=("#async")
    [[ "$words" =~ metric|stat|count|measure ]] && tags+=("#metrics")
    [[ "$words" =~ index|symbol|outline ]] && tags+=("#index")

    # Kind-based tags
    [[ "$kind" == "class" ]] && tags+=("#class")
    [[ "$kind" == "function" && "$words" =~ service$ ]] && tags+=("#service")
    [[ "$kind" == "function" && "$words" =~ manager$ ]] && tags+=("#manager")
    [[ "$kind" == "function" && "$words" =~ helper$ ]] && tags+=("#utility")
    [[ "$kind" == "function" && "$words" =~ util$ ]] && tags+=("#utility")

    # Return unique tags as JSON array (max 5)
    if [ ${#tags[@]} -gt 0 ]; then
        printf '%s\n' "${tags[@]}" | sort -u | head -5 | jq -R . | jq -s .
    else
        echo "[]"
    fi
}

cmd_quickstart() {
    echo -e "${CYAN}${BOLD}‚ö° aOa Quickstart${NC}"
    echo ""

    # Check services first
    if ! curl -s --connect-timeout 2 "${INDEX_URL}/health" > /dev/null 2>&1; then
        echo -e "${RED}‚úó aOa services not running${NC}"
        echo -e "${DIM}Start with: docker start aoa${NC}"
        return 1
    fi

    # Get project info
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="?project=${project_id}"
    fi

    # Get index health
    local health=$(curl -s "${INDEX_URL}/health")
    local files=$(echo "$health" | jq -r '.local.files // 0')
    local symbols=$(echo "$health" | jq -r '.local.symbols // 0')

    echo -e "${GREEN}‚úì${NC} Your codebase is indexed"
    echo -e "  ${BOLD}${files}${NC} files  ‚îÇ  ${BOLD}${symbols}${NC} symbols"
    echo ""
    echo -e "${DIM}Fast search works right now:${NC}"
    echo -e "  ${CYAN}aoa grep <term>${NC}     Symbol lookup (<5ms)"
    echo -e "  ${CYAN}aoa egrep <regex>${NC}   Pattern search"
    echo ""

    # Get pending files for semantic compression
    local pending_result=$(curl -s "${INDEX_URL}/outline/pending${project_param}")
    local pending_count=$(echo "$pending_result" | jq -r '.pending_count // 0')
    local up_to_date=$(echo "$pending_result" | jq -r '.up_to_date_count // 0')

    echo -e "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo -e "${BOLD}Semantic Compression${NC}"
    echo ""

    if [ "$pending_count" -eq 0 ]; then
        echo -e "${GREEN}‚úì${NC} All ${up_to_date} files are compressed"
        echo ""
        echo -e "${DIM}View any file: aoa outline <file>${NC}"
        echo -e "${DIM}Search by meaning: aoa grep '#authentication'${NC}"
        return 0
    fi

    echo -e "  Tagged:   ${GREEN}${up_to_date}${NC} files"
    echo -e "  Pending:  ${YELLOW}${pending_count}${NC} files"
    echo ""
    echo -e "${DIM}Semantic compression creates a structured outline of your code${NC}"
    echo -e "${DIM}(functions, classes, methods). This is FREE - runs locally.${NC}"
    echo ""

    # Show one example
    local example_file=$(echo "$pending_result" | jq -r '.pending[0].file // empty')
    if [ -n "$example_file" ]; then
        echo -e "${BOLD}Example:${NC} ${example_file}"
        echo ""
        # Get outline for this file (just a preview)
        local outline_param=""
        [ -n "$project_id" ] && outline_param="&project=${project_id}"
        local outline=$(curl -s "${INDEX_URL}/outline?file=${example_file}${outline_param}")
        local sym_count=$(echo "$outline" | jq -r '.count // 0')
        local ms=$(echo "$outline" | jq -r '.ms // 0')
        printf "  ${CYAN}‚ö° ${sym_count} symbols${NC} in ${GREEN}%.1fms${NC}\n" "$ms"
        echo "$outline" | jq -r '.symbols[:5][] | "    \(.kind) \(.name) [\(.start_line)-\(.end_line)]"' 2>/dev/null
        local total_syms=$(echo "$outline" | jq -r '.symbols | length')
        if [ "$total_syms" -gt 5 ]; then
            echo -e "    ${DIM}... and $((total_syms - 5)) more${NC}"
        fi
        echo ""
    fi

    # Ask user
    echo -e "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo -e "${BOLD}Run semantic compression on all ${pending_count} files?${NC}"
    echo -e "${DIM}This is free - runs locally, no API calls${NC}"
    echo -e "${DIM}Estimated time: ~$(( pending_count / 20 + 1 )) seconds${NC}"
    echo ""
    read -p "Proceed? [Y/n] " -n 1 -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]] && [[ -n $REPLY ]]; then
        echo -e "${DIM}Skipped. Run 'aoa quickstart' anytime.${NC}"
        return 0
    fi

    echo ""
    echo -e "${BOLD}Processing ${pending_count} files...${NC}"
    echo ""

    # Process each pending file
    local processed=0
    local errors=0

    local loop_param=""
    [ -n "$project_id" ] && loop_param="&project=${project_id}"

    local total_tags=0

    while IFS= read -r file; do
        [ -z "$file" ] && continue

        # Get outline for this file
        local result=$(curl -s "${INDEX_URL}/outline?file=${file}${loop_param}")
        local err=$(echo "$result" | jq -r '.error // empty')

        if [ -n "$err" ]; then
            errors=$((errors + 1))
        else
            # Build symbols array with pattern-inferred tags
            local symbols_with_tags="["
            local first=true

            while IFS= read -r sym_json; do
                [ -z "$sym_json" ] && continue

                local sym_name=$(echo "$sym_json" | jq -r '.name')
                local sym_kind=$(echo "$sym_json" | jq -r '.kind')
                local sym_line=$(echo "$sym_json" | jq -r '.start_line')
                local sym_end=$(echo "$sym_json" | jq -r '.end_line')

                # Infer tags from symbol name (free pattern-based)
                local tags=$(infer_tags_from_name "$sym_name" "$sym_kind")
                local tag_count=$(echo "$tags" | jq 'length')
                total_tags=$((total_tags + tag_count))

                # Build symbol object
                $first || symbols_with_tags+=","
                first=false
                symbols_with_tags+="{\"name\":\"${sym_name}\",\"kind\":\"${sym_kind}\",\"line\":${sym_line},\"end_line\":${sym_end},\"tags\":${tags}}"

            done < <(echo "$result" | jq -c '.symbols[]')

            symbols_with_tags+="]"

            # POST to /outline/enriched with inferred tags
            local mark_payload="{\"file\": \"${file}\", \"project\": \"${project_id}\", \"symbols\": ${symbols_with_tags}}"
            curl -s -X POST "${INDEX_URL}/outline/enriched" \
                -H "Content-Type: application/json" \
                -d "$mark_payload" > /dev/null 2>&1
            processed=$((processed + 1))
        fi

        # Progress indicator every 5 files
        if [ $((processed % 5)) -eq 0 ]; then
            printf "\r  ${GREEN}‚úì${NC} ${processed}/${pending_count} files (${total_tags} tags)"
        fi

    done < <(echo "$pending_result" | jq -r '.pending[].file')

    printf "\r  ${GREEN}‚úì${NC} ${processed}/${pending_count} files, ${total_tags} tags generated\n"
    echo ""

    if [ "$errors" -gt 0 ]; then
        echo -e "${YELLOW}!${NC} ${errors} files had errors (unsupported language)"
    fi

    echo -e "${GREEN}Done!${NC} Semantic compression complete."
    echo ""
    echo -e "  ${BOLD}${total_tags}${NC} tags generated from pattern matching (free)"
    echo ""
    echo -e "${DIM}View any file: aoa outline <file> --tags${NC}"
    echo -e "${DIM}Search by tag: aoa grep '#auth'${NC}"
    echo ""
    echo -e "${DIM}Want richer tags? Say \"tag the codebase\" in Claude for AI-powered tagging${NC}"
}

cmd_baseline() {
    echo -e "${BOLD}aOa Baseline Costs${NC}"
    echo -e "${DIM}Subagent activity tracked from session logs${NC}"
    echo

    local result=$(curl -s "${STATUS_URL}/baseline" 2>/dev/null)

    if [ -z "$result" ]; then
        echo -e "${RED}Could not connect to status service${NC}"
        return 1
    fi

    local total_tokens=$(echo "$result" | jq -r '.baseline.total_tokens // 0')
    local tool_calls=$(echo "$result" | jq -r '.baseline.tool_calls // 0')
    local search_tools=$(echo "$result" | jq -r '.baseline.search_tools // 0')
    local potential_savings=$(echo "$result" | jq -r '.baseline.potential_savings_tokens // 0')
    local last_sync=$(echo "$result" | jq -r '.baseline.last_sync // 0')

    if [ "$total_tokens" -eq 0 ]; then
        echo -e "${DIM}No baseline data yet.${NC}"
        echo -e "${DIM}Subagent sync runs automatically in the background.${NC}"
        return 0
    fi

    # Format tokens
    format_k() {
        local n=$1
        if [ "$n" -ge 1000 ]; then
            echo "$((n / 1000))k"
        else
            echo "$n"
        fi
    }

    local tokens_fmt=$(format_k $total_tokens)
    local savings_fmt=$(format_k $potential_savings)

    echo -e "  ${BOLD}Subagent Activity Observed:${NC}"
    echo -e "    Tool calls: ${CYAN}${tool_calls}${NC}"
    echo -e "    Tokens: ${CYAN}${tokens_fmt}${NC}"
    echo -e "    Grep/Glob used: ${YELLOW}${search_tools}${NC} times"
    echo

    if [ "$potential_savings" -gt 0 ]; then
        local pct=$((potential_savings * 100 / total_tokens))
        echo -e "  ${BOLD}Potential Savings with aOa:${NC}"
        echo -e "    Tokens: ${GREEN}‚Üì${savings_fmt}${NC} ${DIM}(~${pct}% of subagent tokens)${NC}"
        echo -e "    Tool calls: ${GREEN}‚Üì${search_tools}${NC} ${DIM}Grep/Glob ‚Üí aoa search${NC}"
        echo
    fi

    if [ "$last_sync" -gt 0 ]; then
        local now=$(date +%s)
        local age=$((now - last_sync))
        echo -e "  ${DIM}Last sync: ${age}s ago${NC}"
    fi
    echo
}

cmd_metrics() {
    local project_id=$(get_project_id)
    local metrics=$(curl -s --connect-timeout 2 "${INDEX_URL}/metrics?project_id=${project_id}" 2>/dev/null)

    if [ -z "$metrics" ] || echo "$metrics" | jq -e '.error' > /dev/null 2>&1; then
        echo -e "${RED}Metrics not available${NC}"
        return 1
    fi

    # Parse metrics
    local hit_pct=$(echo "$metrics" | jq -r '.rolling.hit_at_5_pct // 0')
    local evaluated=$(echo "$metrics" | jq -r '.rolling.evaluated // 0')
    local hits=$(echo "$metrics" | jq -r '.rolling.hits // 0')
    local tokens_saved=$(echo "$metrics" | jq -r '.savings.tokens // 0')
    local time_saved=$(echo "$metrics" | jq -r '.savings.time_sec // 0')
    local trend=$(echo "$metrics" | jq -r '.trend // "unknown"')

    # Format hit percentage
    local hit_int=$(printf "%.0f" "$hit_pct")

    # Traffic light
    local color=$GREEN
    local light="üü¢"
    if [ "$evaluated" -lt 3 ]; then
        color=$DIM
        light="‚ö™"
    elif [ "$hit_int" -lt 80 ]; then
        color=$YELLOW
        light="üü°"
    fi

    echo -e "${BOLD}aOa Prediction Metrics${NC}"
    echo ""
    echo -e "  Accuracy:     ${color}${light} ${hit_int}%${NC} ${DIM}(${evaluated} evaluated)${NC}"
    echo -e "  Hits:         ${hits}"
    echo -e "  Trend:        ${trend}"
    echo ""
    echo -e "${BOLD}Savings${NC}"
    echo -e "  Tokens:       ${GREEN}‚Üì${tokens_saved}${NC}"
    echo -e "  Time:         ${GREEN}‚ö°${time_saved}s${NC}"
    echo ""
    echo -e "${DIM}Full JSON: aoa metrics --json${NC}"

    # Handle --json flag
    if [[ "${1:-}" == "--json" ]] || [[ "${1:-}" == "-j" ]]; then
        echo ""
        echo "$metrics" | jq .
    fi
}

cmd_history() {
    local limit="${1:-20}"

    curl -s "${STATUS_URL}/history?limit=${limit}" | jq -r '.events[] |
        if .type == "request" then
            "[\(.ts | strftime("%H:%M:%S"))] \(.model) in:\(.input) out:\(.output) $\(.cost)"
        elif .type == "model_switch" then
            "[\(.ts | strftime("%H:%M:%S"))] -> \(.model)"
        elif .type == "block" then
            "[\(.ts | strftime("%H:%M:%S"))] BLOCKED \(.block_type)"
        else
            "[\(.ts | strftime("%H:%M:%S"))] \(.type)"
        end
    '
}

cmd_reset() {
    local target="${1:-session}"

    case "$target" in
        session)
            curl -s -X POST "${STATUS_URL}/session/reset" | jq .
            echo -e "${GREEN}Session reset${NC}"
            ;;
        weekly)
            curl -s -X POST "${STATUS_URL}/weekly/reset" | jq .
            echo -e "${GREEN}Weekly stats reset${NC}"
            ;;
        *)
            echo "Usage: aoa reset [session|weekly]"
            return 1
            ;;
    esac
}

cmd_whitelist() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)
            curl -s "${INDEX_URL}/git/whitelist" | jq -r '
                "Default hosts:", (.default_hosts[] | "  \(.)"),
                "", "Custom hosts:",
                (if .custom_hosts | length > 0 then (.custom_hosts[] | "  \(.)") else "  (none)" end)
            '
            ;;
        add)
            local host="$1"
            if [ -z "$host" ]; then
                echo "Usage: aoa whitelist add <host>"
                echo "Example: aoa whitelist add git.company.com"
                return 1
            fi
            curl -s -X POST "${INDEX_URL}/git/whitelist" \
                -H "Content-Type: application/json" \
                -d "{\"host\": \"${host}\"}" | jq .
            ;;
        remove|rm)
            local host="$1"
            if [ -z "$host" ]; then
                echo "Usage: aoa whitelist remove <host>"
                return 1
            fi
            curl -s -X DELETE "${INDEX_URL}/git/whitelist/${host}" | jq .
            ;;
        *)
            echo -e "${BOLD}Whitelist Management${NC}"
            echo ""
            echo "Commands:"
            echo "  aoa whitelist list         Show allowed URLs"
            echo "  aoa whitelist add <host>   Add URL to whitelist"
            echo "  aoa whitelist remove <h>   Remove URL from whitelist"
            echo ""
            echo "Examples:"
            echo "  aoa whitelist add git.company.com"
            echo "  aoa whitelist add docs.internal.org"
            ;;
    esac
}

cmd_help() {
    cat << 'EOF'
                              AOA
                       5 angles. 1 attack.

GETTING STARTED
  ./install.sh           Install aOa globally (once)
  aoa init               Enable aOa in current project
  aoa remove             Disable aOa in current project
  aoa projects           List all enabled projects

SEARCH (Unix parity)
  grep <term>            O(1) symbol lookup (indexed, full codebase)
  grep "a b c"           Multi-term OR search (ranked)
  grep -a t1,t2          Multi-term AND search (all terms required)
  grep -i <term>         Case insensitive search
  egrep <regex>          Extended regex search (working set only)

FILE DISCOVERY (Unix parity)
  find <pattern>         Find files by glob pattern (e.g., '*.py')
  find -type py          Find files by language
  tree [dir]             Directory tree structure
  locate <name>          Fast filename search
  head <file> [n]        Show first n lines (default: 20)
  tail <file> [n]        Show last n lines (default: 20)
  lines <file> M-N       Show specific line range

BEHAVIORAL (aOa unique)
  hot [limit]            Frequently accessed "hot" files
  touched [since]        Files touched in session/time period
  focus                  Current working set from memory
  predict [file]         Predict next files based on patterns

TIME-BASED
  changes [time]         Recent file changes (e.g., 5m, 1h)
  files [pattern]        List indexed files

OUTLINE ANGLE (code structure + semantic tags)
  outline <file>         Code structure (functions, classes, methods)
  outline --pending      Check tagging status (pending/tagged)
  outline --enrich-all   Show files needing tags (detailed)

  To add semantic tags: In Claude Code, say "tag the codebase"
  Then search: aoa grep "#authentication"

INTENT ANGLE (behavioral tracking)
  intent recent [since]  Recent intent records (e.g., 1h, 30m)
  intent tags            All tags with file counts
  intent files <tag>     Files associated with an intent tag
  intent file <path>     Tags associated with a file
  intent stats           Intent index statistics

SESSION
  history [limit]        Recent events
  reset [session|weekly] Reset counters

INTEL ANGLE (external reference)
  repo list              List intel sources
  repo add <name> <url>  Clone and index a git repo
  repo remove <name>     Remove an intel source
  repo <name> search <t> Search in a specific repo

SYSTEM
  health                 Check all angles
  info                   Show indexing config, mounts, registered projects
  metrics                Prediction accuracy and savings
  baseline               Subagent baseline costs and potential savings
  services               Visual service map with live status

EXAMPLES
  # First time setup
  ./install.sh                  # Install globally (once)
  cd ~/my-project && aoa init   # Enable for project

  # Search your project
  aoa grep handleAuth           # Symbol search
  aoa grep "auth token"         # OR search
  aoa grep -a auth,session      # AND search
  aoa egrep "TODO|FIXME"        # Regex search

  # Add reference repos
  aoa repo add flask https://github.com/pallets/flask
  aoa repo flask search Blueprint

ARCHITECTURE
  ~/.aoa/                Global installation
  .claude/hooks/         Per-project hooks (created by aoa init)

  Install once ‚Üí enable per-project ‚Üí search anywhere

ALIASES
  search, s    ‚Üí grep     (deprecated)
  multi, m     ‚Üí grep -a  (deprecated)
  pattern, p   ‚Üí egrep    (deprecated)

EOF
}

# =============================================================================
# Main
# =============================================================================

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        # Project Management (new in v2)
        init)       cmd_init "$@" ;;
        remove|rm)  cmd_remove "$@" ;;
        projects)   cmd_projects "$@" ;;

        # Session
        history|h)  cmd_history "$@" ;;
        reset)      cmd_reset "$@" ;;

        # Search (Unix parity)
        grep|g)     cmd_grep "$@" ;;
        egrep|eg)   cmd_egrep "$@" ;;

        # Search (deprecated aliases)
        search|s)   cmd_grep "$@" ;;
        multi|m)    cmd_grep -a "$@" ;;
        pattern|p)  cmd_egrep "$@" ;;

        # Local Index
        changes|c)  cmd_changes "$@" ;;
        files|f)    cmd_files "$@" ;;
        outline|o)  cmd_outline "$@" ;;
        enrich|e)   cmd_outline --pending ;;  # Alias - now part of outline

        # File Discovery (Unix parity)
        find)       cmd_find "$@" ;;
        tree)       cmd_tree "$@" ;;
        locate)     cmd_locate "$@" ;;
        head)       cmd_head "$@" ;;
        tail)       cmd_tail "$@" ;;
        lines)      cmd_lines "$@" ;;

        # Behavioral (aOa unique)
        hot)        cmd_hot "$@" ;;
        touched)    cmd_touched "$@" ;;
        focus)      cmd_focus "$@" ;;
        predict)    cmd_predict "$@" ;;

        # Intent Tracking
        intent|i)   cmd_intent "$@" ;;

        # Whitelist Management
        whitelist|w) cmd_whitelist "$@" ;;

        # Knowledge Repos
        repo|r)     cmd_repo "$@" ;;

        # System
        quickstart|qs) cmd_quickstart ;;
        health)     cmd_health ;;
        metrics)    cmd_metrics ;;
        rate)       cmd_rate ;;
        baseline|bl) cmd_baseline ;;
        memory|mem) cmd_memory "$@" ;;
        services|svc|map) cmd_services ;;
        info)       cmd_info ;;
        help|--help|-h) cmd_help ;;

        *)
            echo -e "${RED}Unknown command: $cmd${NC}"
            echo "Run 'aoa help' for usage"
            return 1
            ;;
    esac
}

main "$@"
