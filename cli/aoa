#!/usr/bin/env bash
# aoa - 5 angles. 1 attack.
#
# Global Installation:
#   ./install.sh            Install aOa globally to ~/.aoa/
#
# Per-Project:
#   aoa init                Enable aOa for current project
#   aoa remove              Disable aOa for current project
#   aoa projects            List all enabled projects
#
# Search (after init):
#   aoa search <term>       Search current project
#   aoa multi <t1,t2,...>   Multi-term search
#   aoa health              Check services

set -e

# Configuration
GATEWAY_HOST="${AOA_GATEWAY_HOST:-localhost}"
GATEWAY_PORT="${AOA_GATEWAY_PORT:-8080}"

# Find AOA_HOME by locating the CLI script itself
CLI_PATH="$(readlink -f "$0")"
AOA_HOME="$(dirname "$(dirname "$CLI_PATH")")"
AOA_DATA="${AOA_DATA:-$AOA_HOME/data}"

INDEX_URL="http://${GATEWAY_HOST}:${GATEWAY_PORT}"
STATUS_URL="http://${GATEWAY_HOST}:${GATEWAY_PORT}"

# Colors
BOLD='\033[1m'
DIM='\033[2m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
RED='\033[0;31m'
NC='\033[0m'

# =============================================================================
# Project Management Commands
# =============================================================================

# Get project ID from .aoa/home.json (UUID generated at init)
get_project_id() {
    local project_root=$(get_project_root)
    if [ -z "$project_root" ]; then
        echo ""
        return
    fi

    local home_file="$project_root/.aoa/home.json"
    if [ -f "$home_file" ]; then
        jq -r '.project_id // empty' "$home_file" 2>/dev/null
    fi
}

# Generate a new UUID for project identification
generate_project_id() {
    # Try uuidgen first (Linux/macOS), fall back to Python
    if command -v uuidgen > /dev/null 2>&1; then
        uuidgen | tr '[:upper:]' '[:lower:]'
    else
        python3 -c "import uuid; print(uuid.uuid4())"
    fi
}

# Get project root
get_project_root() {
    git rev-parse --show-toplevel 2>/dev/null
}

# Get project name
get_project_name() {
    local root=$(get_project_root)
    if [ -n "$root" ]; then
        basename "$root"
    fi
}

cmd_init() {
    echo -e "${CYAN}${BOLD}‚ö° aOa - Initializing Project${NC}"
    echo

    # Check if aOa is installed globally
    if [ ! -d "$AOA_HOME" ]; then
        echo -e "${RED}aOa not installed globally.${NC}"
        echo -e "${DIM}Run ./install.sh from the aOa repository first.${NC}"
        return 1
    fi

    # Check if we're in a git repo
    local project_root=$(get_project_root)
    if [ -z "$project_root" ]; then
        echo -e "${RED}Not in a git repository.${NC}"
        echo -e "${DIM}aOa requires a git repo to detect project boundaries.${NC}"
        return 1
    fi

    local project_name=$(get_project_name)

    # Check if already has a project_id, otherwise generate new one
    local existing_id=$(get_project_id)
    local project_id="${existing_id:-$(generate_project_id)}"

    echo -e "  Project: ${BOLD}${project_name}${NC}"
    echo -e "  Path:    ${DIM}${project_root}${NC}"
    echo -e "  ID:      ${DIM}${project_id}${NC}"
    echo

    # Check if already initialized
    if [ -f "$project_root/.claude/hooks/aoa-status-line.sh" ]; then
        echo -e "${YELLOW}Project already initialized.${NC}"
        echo -e "${DIM}Run 'aoa remove' first to reinitialize.${NC}"
        return 0
    fi

    # Create .claude directories
    mkdir -p "$project_root/.claude/hooks"
    mkdir -p "$project_root/.claude/skills"

    # Copy hooks from templates
    echo -n "  Installing hooks.............. "
    cp "$AOA_HOME/plugin/hooks/"*.py "$project_root/.claude/hooks/" 2>/dev/null || true
    cp "$AOA_HOME/plugin/hooks/"*.sh "$project_root/.claude/hooks/" 2>/dev/null || true
    chmod +x "$project_root/.claude/hooks/"*.py "$project_root/.claude/hooks/"*.sh 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Copy skills
    echo -n "  Installing skills............. "
    cp "$AOA_HOME/plugin/skills/"*.md "$project_root/.claude/skills/" 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Copy agents
    echo -n "  Installing agents............. "
    mkdir -p "$project_root/.claude/agents"
    cp "$AOA_HOME/plugin/agents/"*.md "$project_root/.claude/agents/" 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Create .aoa/ folder with home pointer
    echo -n "  Creating .aoa/ config......... "
    mkdir -p "$project_root/.aoa"

    # home.json - project config with UUID identifier
    cat > "$project_root/.aoa/home.json" << EOFHOME
{
  "aoa_home": "$AOA_HOME",
  "data_dir": "$AOA_DATA",
  "project_id": "$project_id",
  "project_root": "$project_root"
}
EOFHOME

    # whitelist.txt - optional repos/URLs for this project
    if [ ! -f "$project_root/.aoa/whitelist.txt" ]; then
        cat > "$project_root/.aoa/whitelist.txt" << 'EOFWHITELIST'
# aOa Whitelist - URLs allowed for this project
# Add one domain per line (HTTPS only)
#
# Examples:
# github.com/your-org/repo
# docs.your-company.com
# internal-git.example.com
EOFWHITELIST
    fi

    # README.md - explains the folder (only if not present)
    if [ ! -f "$project_root/.aoa/README.md" ]; then
        cat > "$project_root/.aoa/README.md" << 'EOFREADME'
# .aoa - aOa Project Link

This folder links this project to your global aOa installation.

## Files

| File | Purpose |
|------|---------|
| `home.json` | Points to global aOa install location |
| `whitelist.txt` | Optional: extra URLs/repos for this project |

## What is aOa?

aOa (Angle of Attack) provides fast O(1) code search for Claude Code.
It replaces slow Grep/Glob operations with indexed symbol lookup.

## Commands

```bash
aoa search <term>    # Search this project
aoa health           # Check services
aoa remove           # Remove aOa from this project
```

## Global Settings

To change aOa settings (port, confidence threshold, etc.),
edit the config.json in your global aOa installation.
EOFREADME
    fi
    echo -e "${GREEN}‚úì${NC}"

    # Copy or merge settings template
    echo -n "  Merging settings.............. "
    if [ ! -f "$project_root/.claude/settings.local.json" ]; then
        # No existing settings - copy template
        cp "$AOA_DATA/settings.template.json" "$project_root/.claude/settings.local.json"
        echo -e "${GREEN}‚úì${NC}"
    else
        # Backup existing settings
        cp "$project_root/.claude/settings.local.json" \
           "$project_root/.claude/settings.local.json.pre-aoa-$(date +%Y%m%d-%H%M%S)"

        # Deep merge: preserve their settings, add our hooks/statusLine/permissions
        jq -s '
            # Start with their settings (index 1)
            .[1] as $existing |
            # Our template (index 0)
            .[0] as $template |

            # Merge strategy:
            # - permissions.allow: union (combine both)
            # - hooks: merge by type (combine hook arrays)
            # - statusLine: use ours if missing
            # - everything else: preserve theirs

            $existing |
            # Add our statusLine if missing
            (if .statusLine == null then .statusLine = $template.statusLine else . end) |
            # Merge permissions.allow
            (if .permissions.allow then
                .permissions.allow += $template.permissions.allow | .permissions.allow |= unique
             else
                .permissions = $template.permissions
             end) |
            # Merge hooks (deep merge by hook type)
            (if .hooks then
                .hooks = ($template.hooks * .hooks)
             else
                .hooks = $template.hooks
             end)
        ' "$AOA_DATA/settings.template.json" "$project_root/.claude/settings.local.json" \
          > "$project_root/.claude/settings.local.json.new"

        mv "$project_root/.claude/settings.local.json.new" "$project_root/.claude/settings.local.json"
        echo -e "${GREEN}‚úì${NC} ${DIM}(merged, backup created)${NC}"
    fi

    # Register project in projects.json
    echo -n "  Registering project........... "
    local projects_file="$AOA_DATA/projects.json"
    local now=$(date -Iseconds)

    # Create entry
    local entry=$(jq -n \
        --arg id "$project_id" \
        --arg name "$project_name" \
        --arg path "$project_root" \
        --arg added "$now" \
        '{id: $id, name: $name, path: $path, added: $added}')

    # Add to projects.json (remove existing entry with same id first)
    local updated=$(jq --arg id "$project_id" 'map(select(.id != $id))' "$projects_file")
    echo "$updated" | jq --argjson entry "$entry" '. + [$entry]' > "$projects_file.tmp"
    mv "$projects_file.tmp" "$projects_file"
    echo -e "${GREEN}‚úì${NC}"

    # Trigger initial index
    echo -n "  Indexing project.............. "
    local index_result=$(curl -s -X POST "${INDEX_URL}/project/register" \
        -H "Content-Type: application/json" \
        -d "{\"id\": \"${project_id}\", \"name\": \"${project_name}\", \"path\": \"${project_root}\"}" 2>/dev/null)

    if echo "$index_result" | jq -e '.success' > /dev/null 2>&1; then
        local file_count=$(echo "$index_result" | jq -r '.files // 0')
        echo -e "${GREEN}‚úì${NC} ${DIM}(${file_count} files)${NC}"
    else
        echo -e "${YELLOW}pending${NC} ${DIM}(will index on first search)${NC}"
    fi

    echo
    echo -e "${GREEN}${BOLD}‚úì aOa enabled for ${project_name}${NC}"
    echo
    echo -e "${DIM}Restart Claude Code to activate hooks.${NC}"
    echo -e "${DIM}Then try: aoa search <term>${NC}"
    echo
}

cmd_remove() {
    echo -e "${CYAN}${BOLD}‚ö° aOa - Removing from Project${NC}"
    echo

    local project_root=$(get_project_root)
    if [ -z "$project_root" ]; then
        echo -e "${RED}Not in a git repository.${NC}"
        return 1
    fi

    local project_id=$(get_project_id)
    local project_name=$(get_project_name)

    echo -e "  Project: ${BOLD}${project_name}${NC}"
    echo

    # Check if initialized
    if [ ! -f "$project_root/.claude/hooks/aoa-status-line.sh" ]; then
        echo -e "${DIM}aOa not initialized in this project.${NC}"
        return 0
    fi

    # Remove hooks
    echo -n "  Removing hooks................ "
    rm -f "$project_root/.claude/hooks/aoa-"* 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Remove skills
    echo -n "  Removing skills............... "
    rm -f "$project_root/.claude/skills/aoa.md" 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Remove agents
    echo -n "  Removing agents............... "
    rm -f "$project_root/.claude/agents/aoa-"* 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Remove entire .aoa/ folder (full cleanup)
    echo -n "  Removing .aoa/ folder......... "
    rm -rf "$project_root/.aoa" 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    # Remove from projects.json
    echo -n "  Unregistering project......... "
    local projects_file="$AOA_DATA/projects.json"
    if [ -f "$projects_file" ]; then
        jq --arg id "$project_id" 'map(select(.id != $id))' "$projects_file" > "$projects_file.tmp"
        mv "$projects_file.tmp" "$projects_file"
    fi
    echo -e "${GREEN}‚úì${NC}"

    # Notify service to remove index
    echo -n "  Removing index................ "
    curl -s -X DELETE "${INDEX_URL}/project/${project_id}" > /dev/null 2>&1 || true
    echo -e "${GREEN}‚úì${NC}"

    # Restore settings from backup if available
    echo -n "  Restoring settings............ "
    # Find the most recent backup
    local backup=$(ls -t "$project_root/.claude/settings.local.json.pre-aoa-"* 2>/dev/null | head -1)

    if [ -f "$project_root/.claude/settings.local.json" ]; then
        if [ -n "$backup" ]; then
            # Backup exists - restore original settings
            mv "$backup" "$project_root/.claude/settings.local.json"
            # Clean up any other backups
            rm -f "$project_root/.claude/settings.local.json.pre-aoa-"* 2>/dev/null
            echo -e "${GREEN}restored from backup${NC}"
        else
            # No backup - check if it's just our template
            local template_hash=$(md5sum "$AOA_DATA/settings.template.json" 2>/dev/null | cut -d' ' -f1)
            local settings_hash=$(md5sum "$project_root/.claude/settings.local.json" 2>/dev/null | cut -d' ' -f1)

            if [ "$template_hash" = "$settings_hash" ]; then
                rm -f "$project_root/.claude/settings.local.json"
                echo -e "${GREEN}removed${NC}"
            else
                echo -e "${YELLOW}preserved (has customizations)${NC}"
            fi
        fi
    else
        echo -e "${DIM}not found${NC}"
    fi

    # Clean up empty directories
    echo -n "  Cleaning directories.......... "
    rmdir "$project_root/.claude/hooks" 2>/dev/null || true
    rmdir "$project_root/.claude/skills" 2>/dev/null || true
    rmdir "$project_root/.claude/agents" 2>/dev/null || true
    rmdir "$project_root/.claude" 2>/dev/null || true
    echo -e "${GREEN}‚úì${NC}"

    echo
    echo -e "${GREEN}${BOLD}‚úì aOa removed from ${project_name}${NC}"
    echo
    echo -e "${DIM}Restart Claude Code to deactivate hooks.${NC}"
    echo
}

cmd_projects() {
    echo -e "${BOLD}aOa Projects${NC}"
    echo

    local projects_file="$AOA_DATA/projects.json"

    if [ ! -f "$projects_file" ]; then
        echo -e "${DIM}No projects registered.${NC}"
        echo -e "${DIM}Run 'aoa init' in a project to enable aOa.${NC}"
        return 0
    fi

    local count=$(jq 'length' "$projects_file" 2>/dev/null)

    if [ "$count" = "0" ] || [ -z "$count" ]; then
        echo -e "${DIM}No projects registered.${NC}"
        echo -e "${DIM}Run 'aoa init' in a project to enable aOa.${NC}"
        return 0
    fi

    # Get current project for highlighting
    local current_id=$(get_project_id)

    # List projects
    jq -r '.[] | "\(.id)|\(.name)|\(.path)"' "$projects_file" | while IFS='|' read -r id name path; do
        if [ "$id" = "$current_id" ]; then
            echo -e "  ${GREEN}‚ñ∏${NC} ${BOLD}${name}${NC} ${DIM}${path}${NC} ${GREEN}(current)${NC}"
        else
            # Check if path still exists
            if [ -d "$path" ]; then
                echo -e "  ${DIM}‚Ä¢${NC} ${name} ${DIM}${path}${NC}"
            else
                echo -e "  ${RED}‚úó${NC} ${name} ${DIM}${path}${NC} ${RED}(missing)${NC}"
            fi
        fi
    done

    echo
    echo -e "${DIM}${count} project(s) registered${NC}"
}

# =============================================================================
# Status Commands
# =============================================================================

cmd_status() {
    local watch=false
    local json=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -w|--watch) watch=true; shift ;;
            -j|--json) json=true; shift ;;
            *) shift ;;
        esac
    done

    if $json; then
        curl -s "${STATUS_URL}/status/json" | jq .
        return
    fi

    if $watch; then
        echo -e "${DIM}Press Ctrl+C to exit${NC}"
        echo ""
        while true; do
            # Move cursor up and clear line
            tput cuu1 2>/dev/null || true
            tput el 2>/dev/null || true

            # Get and display status
            local line=$(curl -s "${STATUS_URL}/status" 2>/dev/null || echo "Status service unavailable")
            echo -e "${CYAN}${line}${NC}"

            sleep 1
        done
    else
        local line=$(curl -s "${STATUS_URL}/status" 2>/dev/null)
        if [ -n "$line" ]; then
            echo -e "${CYAN}‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê${NC}"
            echo -e "${CYAN}‚îÇ${NC} ${line} ${CYAN}‚îÇ${NC}"
            echo -e "${CYAN}‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò${NC}"
        else
            echo -e "${RED}Status service not available at ${STATUS_URL}${NC}"
            return 1
        fi
    fi
}

# =============================================================================
# Local Index Commands (default)
# =============================================================================

cmd_search() {
    local query="$1"
    local mode="${2:-recent}"
    local limit="${3:-20}"

    if [ -z "$query" ]; then
        echo "Usage: aoa search <term> [mode] [limit]"
        return 1
    fi

    # Get current project context
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/symbol?q=${query}&mode=${mode}&limit=${limit}${project_param}")
    local ms=$(echo "$result" | jq -r '.ms // 0')
    local count=$(echo "$result" | jq -r '.results | length')

    # Single punchy line: ‚ö° 7 hits ‚îÇ 0.12ms
    printf "${CYAN}${BOLD}‚ö° %s hits${NC} ${DIM}‚îÇ${NC} ${GREEN}%.2fms${NC}\n" "$count" "$ms"

    # Results
    echo "$result" | jq -r '.results[] | "  \(.file):\(.line)"' 2>/dev/null
}

cmd_multi() {
    local terms="$1"
    local mode="${2:-recent}"
    local limit="${3:-20}"

    if [ -z "$terms" ]; then
        echo "Usage: aoa multi <term1,term2,...> [mode] [limit]"
        return 1
    fi

    # Get current project context
    local project_id=$(get_project_id)

    # Convert to JSON array
    local json_terms=$(echo "$terms" | tr ',' '\n' | jq -R . | jq -s .)

    local body="{\"terms\": ${json_terms}, \"mode\": \"${mode}\", \"limit\": ${limit}"
    if [ -n "$project_id" ]; then
        body="${body}, \"project\": \"${project_id}\""
    fi
    body="${body}}"

    local result=$(curl -s -X POST "${INDEX_URL}/multi" \
        -H "Content-Type: application/json" \
        -d "$body")

    local ms=$(echo "$result" | jq -r '.ms // 0')
    local count=$(echo "$result" | jq -r '.results | length')

    # Single punchy line
    printf "${CYAN}${BOLD}‚ö° %s hits${NC} ${DIM}‚îÇ${NC} ${GREEN}%.2fms${NC}\n" "$count" "$ms"

    echo "$result" | jq -r '.results[] | "  \(.file):\(.line)"' 2>/dev/null
}

cmd_changes() {
    local since="${1:-300}"
    local project_id=$(get_project_id)

    # Parse time strings
    if [[ "$since" =~ ^([0-9]+)([smh])$ ]]; then
        local num="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2]}"
        case "$unit" in
            s) since=$num ;;
            m) since=$((num * 60)) ;;
            h) since=$((num * 3600)) ;;
        esac
    fi

    local result=$(curl -s "${INDEX_URL}/changes?since=${since}&project_id=${project_id}")

    echo -e "${GREEN}Added:${NC}"
    echo "$result" | jq -r '.added[]' 2>/dev/null || echo "  (none)"

    echo -e "${YELLOW}Modified:${NC}"
    echo "$result" | jq -r '.modified[].file' 2>/dev/null || echo "  (none)"

    echo -e "${RED}Deleted:${NC}"
    echo "$result" | jq -r '.deleted[]' 2>/dev/null || echo "  (none)"
}

cmd_files() {
    local pattern="$1"
    local mode="${2:-recent}"
    local limit="${3:-30}"

    local url="${INDEX_URL}/files?mode=${mode}&limit=${limit}"
    [ -n "$pattern" ] && url="${url}&match=${pattern}"

    curl -s "$url" | jq -r '.results[] | "\(.path) (\(.language))"'
}

cmd_outline() {
    local file=""
    local enrich=false
    local enrich_all=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --enrich)
                enrich=true
                shift
                ;;
            --enrich-all)
                enrich_all=true
                shift
                ;;
            -*)
                echo "Unknown option: $1"
                return 1
                ;;
            *)
                file="$1"
                shift
                ;;
        esac
    done

    # Handle --enrich-all (batch mode)
    if $enrich_all; then
        echo -e "${CYAN}${BOLD}‚ö° aOa Outline - Batch Enrich${NC}"
        echo ""

        # Get current project context
        local project_id=$(get_project_id)
        local project_param=""
        if [ -n "$project_id" ]; then
            project_param="?project=${project_id}"
        fi

        # Get pending files from the service
        local result=$(curl -s "${INDEX_URL}/outline/pending${project_param}")

        local pending_count=$(echo "$result" | jq -r '.pending_count // 0')
        local up_to_date=$(echo "$result" | jq -r '.up_to_date_count // 0')
        local total=$(echo "$result" | jq -r '.total_files // 0')
        local ms=$(echo "$result" | jq -r '.ms // 0')

        printf "Scanned project in ${GREEN}%.1fms${NC}\n" "$ms"
        echo ""
        echo -e "  Total files:      ${BOLD}${total}${NC}"
        echo -e "  Already enriched: ${GREEN}${up_to_date}${NC} ${DIM}(up to date)${NC}"
        echo -e "  Need enrichment:  ${YELLOW}${pending_count}${NC}"
        echo ""

        if [ "$pending_count" -eq 0 ]; then
            echo -e "${GREEN}All files are up to date!${NC}"
            return 0
        fi

        echo -e "${BOLD}Files to enrich:${NC}"
        echo "$result" | jq -r '.pending[:10][] | "  \(.file) (\(.reason))"' 2>/dev/null

        if [ "$pending_count" -gt 10 ]; then
            echo -e "  ${DIM}... and $((pending_count - 10)) more${NC}"
        fi

        echo ""
        echo -e "${BLUE}‚îÄ‚îÄ‚îÄ Enrichment ‚îÄ‚îÄ‚îÄ${NC}"
        echo ""
        echo -e "${DIM}Claude should spawn Haiku tasks for each pending file.${NC}"
        echo -e "${DIM}After enriching, mark complete via: POST /outline/enriched${NC}"
        echo ""
        echo "ENRICH_BATCH_REQUEST:"
        echo "$result" | jq -c '{pending: .pending, project: "'"${project_id}"'"}'
        return 0
    fi

    if [ -z "$file" ]; then
        echo "Usage: aoa outline <file> [--enrich]"
        echo "       aoa outline --enrich-all"
        echo ""
        echo "Options:"
        echo "  --enrich      Add AI-generated intent tags (requires Claude Code)"
        echo "  --enrich-all  Batch enrich all project files (requires Claude Code)"
        echo ""
        echo "Examples:"
        echo "  aoa outline src/index.ts"
        echo "  aoa outline services/auth.py --enrich"
        return 1
    fi

    # Get current project context
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/outline?file=${file}${project_param}")

    # Check for errors
    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        local msg=$(echo "$result" | jq -r '.message // empty')
        [ -n "$msg" ] && echo -e "${DIM}${msg}${NC}"
        return 1
    fi

    local count=$(echo "$result" | jq -r '.count // 0')
    local ms=$(echo "$result" | jq -r '.ms // 0')
    local lang=$(echo "$result" | jq -r '.language // "unknown"')

    # Header
    if $enrich; then
        printf "${CYAN}${BOLD}‚ö° %s symbols${NC} ${DIM}‚îÇ${NC} ${GREEN}%.2fms${NC} ${DIM}‚îÇ${NC} ${YELLOW}%s${NC} ${DIM}‚îÇ${NC} ${BLUE}enrichment requested${NC}\n" "$count" "$ms" "$lang"
    else
        printf "${CYAN}${BOLD}‚ö° %s symbols${NC} ${DIM}‚îÇ${NC} ${GREEN}%.2fms${NC} ${DIM}‚îÇ${NC} ${YELLOW}%s${NC}\n" "$count" "$ms" "$lang"
    fi
    echo ""

    # Output symbols with line ranges
    echo "$result" | jq -r '.symbols[] | "  \(.kind) \(.name) [\(.start_line)-\(.end_line)]"' 2>/dev/null

    # If enrichment requested, output instructions for Claude
    if $enrich; then
        echo ""
        echo -e "${BLUE}‚îÄ‚îÄ‚îÄ Enrichment ‚îÄ‚îÄ‚îÄ${NC}"
        echo ""
        echo -e "${DIM}To enrich these symbols with AI-generated tags, Claude should:${NC}"
        echo -e "${DIM}1. Extract signatures from the outline above${NC}"
        echo -e "${DIM}2. Spawn a Haiku task to generate 2-4 intent tags per symbol${NC}"
        echo -e "${DIM}3. Store tags via: POST /intent with tags array${NC}"
        echo ""
        # Output JSON for Claude to use
        echo "ENRICH_REQUEST:"
        echo "$result" | jq -c '{file: .file, language: .language, symbols: [.symbols[] | {name: .name, kind: .kind, signature: .signature}]}'
    fi
}

# =============================================================================
# Knowledge Repo Commands
# =============================================================================

cmd_repo() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)
            cmd_repo_list "$@"
            ;;
        add)
            cmd_repo_add "$@"
            ;;
        remove|rm)
            cmd_repo_remove "$@"
            ;;
        *)
            # Assume it's a repo name - dispatch to repo-specific commands
            local repo_name="$subcmd"
            local repo_cmd="${1:-help}"
            shift || true

            case "$repo_cmd" in
                search|s)
                    cmd_repo_search "$repo_name" "$@"
                    ;;
                multi|m)
                    cmd_repo_multi "$repo_name" "$@"
                    ;;
                files|f)
                    cmd_repo_files "$repo_name" "$@"
                    ;;
                file)
                    cmd_repo_file "$repo_name" "$@"
                    ;;
                deps)
                    cmd_repo_deps "$repo_name" "$@"
                    ;;
                *)
                    echo -e "${BOLD}Repo: ${repo_name}${NC}"
                    echo ""
                    echo "Commands:"
                    echo "  aoa repo ${repo_name} search <term>   Search in ${repo_name}"
                    echo "  aoa repo ${repo_name} multi <t1,t2>  Multi-term search"
                    echo "  aoa repo ${repo_name} files [pat]    List files"
                    echo "  aoa repo ${repo_name} file <path>    Get file content"
                    echo "  aoa repo ${repo_name} deps <file>    Get dependencies"
                    ;;
            esac
            ;;
    esac
}

cmd_repo_list() {
    echo -e "${BOLD}Knowledge Repos${NC}"
    echo ""

    local result=$(curl -s "${INDEX_URL}/repos")
    local count=$(echo "$result" | jq '.repos | length')

    if [ "$count" == "0" ]; then
        echo -e "${DIM}No knowledge repos. Add one with:${NC}"
        echo "  aoa repo add <name> <git-url>"
        return
    fi

    echo "$result" | jq -r '.repos[] | "  \(.name): \(.files) files, \(.symbols) symbols"'
}

cmd_repo_add() {
    local name="$1"
    local url="$2"

    if [ -z "$name" ] || [ -z "$url" ]; then
        echo "Usage: aoa repo add <name> <git-url>"
        echo ""
        echo "Examples:"
        echo "  aoa repo add flask https://github.com/pallets/flask"
        echo "  aoa repo add react https://github.com/facebook/react"
        return 1
    fi

    echo -e "${DIM}Cloning and indexing ${name}...${NC}"

    local result=$(curl -s -X POST "${INDEX_URL}/repos" \
        -H "Content-Type: application/json" \
        -d "{\"name\": \"${name}\", \"url\": \"${url}\"}")

    local success=$(echo "$result" | jq -r '.success // false')

    if [ "$success" == "true" ]; then
        local msg=$(echo "$result" | jq -r '.message')
        echo -e "${GREEN}${msg}${NC}"
    else
        local err=$(echo "$result" | jq -r '.error // "Unknown error"')
        echo -e "${RED}Failed: ${err}${NC}"
        return 1
    fi
}

cmd_repo_remove() {
    local name="$1"

    if [ -z "$name" ]; then
        echo "Usage: aoa repo remove <name>"
        return 1
    fi

    echo -e "${DIM}Removing ${name}...${NC}"

    local result=$(curl -s -X DELETE "${INDEX_URL}/repos/${name}")

    local success=$(echo "$result" | jq -r '.success // false')

    if [ "$success" == "true" ]; then
        echo -e "${GREEN}Repo '${name}' removed${NC}"
    else
        local err=$(echo "$result" | jq -r '.error // "Unknown error"')
        echo -e "${RED}Failed: ${err}${NC}"
        return 1
    fi
}

cmd_repo_search() {
    local repo_name="$1"
    local query="$2"
    local mode="${3:-recent}"
    local limit="${4:-20}"

    if [ -z "$query" ]; then
        echo "Usage: aoa repo ${repo_name} search <term> [mode] [limit]"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/repo/${repo_name}/symbol?q=${query}&mode=${mode}&limit=${limit}")

    # Check for error
    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    local ms=$(echo "$result" | jq -r '.ms // 0')
    local count=$(echo "$result" | jq -r '.results | length')

    # Single punchy line with repo indicator
    printf "${CYAN}${BOLD}‚ö° %s hits${NC} ${DIM}‚îÇ${NC} ${GREEN}%.2fms${NC} ${DIM}‚îÇ${NC} ${YELLOW}%s${NC}\n" "$count" "$ms" "$repo_name"

    echo "$result" | jq -r '.results[] | "  \(.file):\(.line)"' 2>/dev/null
}

cmd_repo_multi() {
    local repo_name="$1"
    local terms="$2"
    local mode="${3:-recent}"
    local limit="${4:-20}"

    if [ -z "$terms" ]; then
        echo "Usage: aoa repo ${repo_name} multi <term1,term2,...> [mode] [limit]"
        return 1
    fi

    local json_terms=$(echo "$terms" | tr ',' '\n' | jq -R . | jq -s .)

    local result=$(curl -s -X POST "${INDEX_URL}/repo/${repo_name}/multi" \
        -H "Content-Type: application/json" \
        -d "{\"terms\": ${json_terms}, \"mode\": \"${mode}\", \"limit\": ${limit}}")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    local ms=$(echo "$result" | jq -r '.ms // 0')

    echo -e "${DIM}Found in ${ms}ms (${repo_name}):${NC}"
    echo "$result" | jq -r '.results[] | "\(.file):\(.line)"' 2>/dev/null || echo "No results"
}

cmd_repo_files() {
    local repo_name="$1"
    local pattern="$2"
    local mode="${3:-recent}"
    local limit="${4:-30}"

    local url="${INDEX_URL}/repo/${repo_name}/files?mode=${mode}&limit=${limit}"
    [ -n "$pattern" ] && url="${url}&match=${pattern}"

    local result=$(curl -s "$url")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    echo "$result" | jq -r '.results[] | "\(.path) (\(.language))"'
}

cmd_repo_file() {
    local repo_name="$1"
    local path="$2"
    local lines="$3"

    if [ -z "$path" ]; then
        echo "Usage: aoa repo ${repo_name} file <path> [lines]"
        echo "  lines: e.g., 10-50"
        return 1
    fi

    local url="${INDEX_URL}/repo/${repo_name}/file?path=${path}"
    [ -n "$lines" ] && url="${url}&lines=${lines}"

    local result=$(curl -s "$url")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    echo "$result" | jq -r '.content'
}

cmd_repo_deps() {
    local repo_name="$1"
    local file="$2"
    local direction="${3:-outgoing}"

    if [ -z "$file" ]; then
        echo "Usage: aoa repo ${repo_name} deps <file> [outgoing|incoming]"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/repo/${repo_name}/deps?file=${file}&direction=${direction}")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    echo -e "${BOLD}${direction} dependencies for ${file}:${NC}"
    echo "$result" | jq -r '.dependencies[]' 2>/dev/null || echo "  (none)"
}

# =============================================================================
# Pattern Search (Agent-driven)
# =============================================================================

cmd_pattern() {
    # Usage: aoa pattern '{"func_def": "def\\s+\\w+"}' [--repo name] [--since 7d]
    local patterns="$1"
    shift || true

    local repo=""
    local since=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --repo|-r) repo="$2"; shift 2 ;;
            --since|-s) since="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    if [ -z "$patterns" ]; then
        echo "Usage: aoa pattern '<json patterns>' [--repo name] [--since time]"
        echo ""
        echo "Examples:"
        echo '  aoa pattern '\''{"func": "def\\s+\\w+\\("}'\'''
        echo '  aoa pattern '\''{"class": "class\\s+\\w+"}'\'' --repo flask'
        echo '  aoa pattern '\''{"error": "except\\s+\\w+"}'\'' --since 7d'
        return 1
    fi

    # Parse since time string
    local since_seconds=""
    if [ -n "$since" ]; then
        if [[ "$since" =~ ^([0-9]+)([smhd])$ ]]; then
            local num="${BASH_REMATCH[1]}"
            local unit="${BASH_REMATCH[2]}"
            case "$unit" in
                s) since_seconds=$num ;;
                m) since_seconds=$((num * 60)) ;;
                h) since_seconds=$((num * 3600)) ;;
                d) since_seconds=$((num * 86400)) ;;
            esac
        else
            since_seconds="$since"
        fi
    fi

    # Build request body
    local body="{\"patterns\": ${patterns}"
    [ -n "$repo" ] && body="${body}, \"repo\": \"${repo}\""
    [ -n "$since_seconds" ] && body="${body}, \"since\": ${since_seconds}"
    body="${body}}"

    local url="${INDEX_URL}/pattern"
    [ -n "$repo" ] && url="${INDEX_URL}/repo/${repo}/pattern"

    local result=$(curl -s -X POST "$url" \
        -H "Content-Type: application/json" \
        -d "$body")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    local ms=$(echo "$result" | jq -r '.stats.ms')
    local files=$(echo "$result" | jq -r '.stats.files_searched')
    local matched=$(echo "$result" | jq -r '.stats.files_matched')
    local idx=$(echo "$result" | jq -r '.index')

    echo -e "${DIM}Pattern search in ${idx}: ${files} files, ${matched} matched, ${ms}ms${NC}"
    echo ""

    # Output results grouped by pattern
    echo "$result" | jq -r '.results | to_entries[] | "\u001b[1m\(.key):\u001b[0m", (.value[] | "  \(.file):\(.line) \u001b[2m\(.context)\u001b[0m"), ""'
}

# =============================================================================
# Intent Commands
# =============================================================================

cmd_intent() {
    local subcmd="${1:-recent}"
    shift || true

    case "$subcmd" in
        recent|r)
            cmd_intent_recent "$@"
            ;;
        tags|t)
            cmd_intent_tags "$@"
            ;;
        files|f)
            cmd_intent_files "$@"
            ;;
        file)
            cmd_intent_file "$@"
            ;;
        stats)
            cmd_intent_stats "$@"
            ;;
        *)
            echo -e "${BOLD}Intent Tracking${NC}"
            echo ""
            echo "Commands:"
            echo "  aoa intent recent [since]   Recent intent records (e.g., 1h, 30m)"
            echo "  aoa intent tags             All tags with file counts"
            echo "  aoa intent files <tag>      Files associated with a tag"
            echo "  aoa intent file <path>      Tags associated with a file"
            echo "  aoa intent stats            Intent index statistics"
            ;;
    esac
}

cmd_intent_recent() {
    local since="${1:-3600}"
    local project_id=$(get_project_id)

    # Parse time strings
    if [[ "$since" =~ ^([0-9]+)([smh])$ ]]; then
        local num="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2]}"
        case "$unit" in
            s) since=$num ;;
            m) since=$((num * 60)) ;;
            h) since=$((num * 3600)) ;;
        esac
    fi

    local result=$(curl -s "${INDEX_URL}/intent/recent?since=${since}&limit=30&project_id=${project_id}")

    local stats=$(echo "$result" | jq -r '.stats')
    local total=$(echo "$stats" | jq -r '.total_records')
    local tags=$(echo "$stats" | jq -r '.unique_tags')
    local files=$(echo "$stats" | jq -r '.unique_files')

    echo -e "${BOLD}Intent Activity${NC} ${DIM}‚îÇ${NC} ${total} records, ${tags} tags, ${files} files"
    echo ""

    echo "$result" | jq -r '.records[] |
        "  \(.tool | .[0:6]) ‚îÇ \(.tags | join(" ")) ‚îÇ \(.files | join(", ") | .[0:50])"
    ' 2>/dev/null || echo "  (no recent activity)"
}

cmd_intent_tags() {
    local project_id=$(get_project_id)
    local result=$(curl -s "${INDEX_URL}/intent/tags?project_id=${project_id}")

    echo -e "${BOLD}Intent Tags${NC}"
    echo ""

    echo "$result" | jq -r '.tags[] | "  \(.tag) (\(.count) files)"' 2>/dev/null || echo "  (no tags yet)"
}

cmd_intent_files() {
    local tag="$1"
    local project_id=$(get_project_id)

    if [ -z "$tag" ]; then
        echo "Usage: aoa intent files <tag>"
        echo "Example: aoa intent files authentication"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/intent/files?tag=${tag}&project_id=${project_id}")

    local actual_tag=$(echo "$result" | jq -r '.tag')
    echo -e "${BOLD}Files for ${actual_tag}${NC}"
    echo ""

    echo "$result" | jq -r '.files[]' 2>/dev/null || echo "  (no files)"
}

cmd_intent_file() {
    local path="$1"
    local project_id=$(get_project_id)

    if [ -z "$path" ]; then
        echo "Usage: aoa intent file <path>"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/intent/file?path=${path}&project_id=${project_id}")

    echo -e "${BOLD}Tags for ${path}${NC}"
    echo ""

    echo "$result" | jq -r '.tags[]' 2>/dev/null || echo "  (no tags)"
}

cmd_intent_stats() {
    local project_id=$(get_project_id)
    local result=$(curl -s "${INDEX_URL}/intent/stats?project_id=${project_id}")

    echo -e "${BOLD}Intent Index Stats${NC}"
    echo ""

    echo "$result" | jq -r '"  Records: \(.total_records)", "  Tags: \(.unique_tags)", "  Files: \(.unique_files)", "  Sessions: \(.sessions)"'
}

# =============================================================================
# Utility Commands
# =============================================================================

cmd_services() {
    echo -e "${CYAN}${BOLD}"
    cat << 'EOF'
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                         aOa Attack Map                               ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                                      ‚ïë
‚ïë  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚ïë
‚ïë  ‚îÇ                     GATEWAY (:8080)                         ‚îÇ    ‚ïë
‚ïë  ‚îÇ              Single entry point for all angles              ‚îÇ    ‚ïë
‚ïë  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚ïë
‚ïë                              ‚îÇ                                       ‚ïë
‚ïë          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚ïë
‚ïë          ‚ñº                   ‚ñº                   ‚ñº                  ‚ïë
‚ïë  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚ïë
‚ïë  ‚îÇ    INDEX      ‚îÇ   ‚îÇ    STATUS     ‚îÇ   ‚îÇ   GIT-PROXY   ‚îÇ         ‚ïë
‚ïë  ‚îÇ    :9999      ‚îÇ   ‚îÇ    :9998      ‚îÇ   ‚îÇ    :9997      ‚îÇ         ‚ïë
‚ïë  ‚îÇ               ‚îÇ   ‚îÇ               ‚îÇ   ‚îÇ               ‚îÇ         ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Symbol      ‚îÇ   ‚îÇ ‚Ä¢ Sessions    ‚îÇ   ‚îÇ ‚Ä¢ Clone repos ‚îÇ         ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Ranking     ‚îÇ   ‚îÇ ‚Ä¢ History     ‚îÇ   ‚îÇ ‚Ä¢ Allowlist   ‚îÇ         ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Intent      ‚îÇ   ‚îÇ ‚Ä¢ Metrics     ‚îÇ   ‚îÇ               ‚îÇ         ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Memory      ‚îÇ   ‚îÇ               ‚îÇ   ‚îÇ               ‚îÇ         ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Tuner       ‚îÇ   ‚îÇ               ‚îÇ   ‚îÇ               ‚îÇ         ‚ïë
‚ïë  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚ïë
‚ïë          ‚îÇ                                                          ‚ïë
‚ïë          ‚ñº                                                          ‚ïë
‚ïë  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                                  ‚ïë
‚ïë  ‚îÇ    REDIS      ‚îÇ                                                  ‚ïë
‚ïë  ‚îÇ    :6379      ‚îÇ                                                  ‚ïë
‚ïë  ‚îÇ               ‚îÇ                                                  ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Scores      ‚îÇ                                                  ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Transitions ‚îÇ                                                  ‚ïë
‚ïë  ‚îÇ ‚Ä¢ Predictions ‚îÇ                                                  ‚ïë
‚ïë  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                                  ‚ïë
‚ïë                                                                      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  THE FIVE ANGLES                                                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                                      ‚ïë
‚ïë  ‚ö° SYMBOL         O(1) symbol lookup across codebase                ‚ïë
‚ïë     aoa search <term>                                                ‚ïë
‚ïë                                                                      ‚ïë
‚ïë  üéØ INTENT         Track tool calls, extract behavior patterns       ‚ïë
‚ïë     aoa intent recent                                                ‚ïë
‚ïë                                                                      ‚ïë
‚ïë  üß† STRIKE         Predictive context, dynamic working memory        ‚ïë
‚ïë     aoa context "fix auth bug"                                       ‚ïë
‚ïë                                                                      ‚ïë
‚ïë  üìä SIGNAL         Multi-term ranking, pattern matching              ‚ïë
‚ïë     aoa multi auth,session                                           ‚ïë
‚ïë                                                                      ‚ïë
‚ïë  üìÅ INTEL          External reference repos, isolated search         ‚ïë
‚ïë     aoa repo <name> search <term>                                    ‚ïë
‚ïë                                                                      ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
    echo -e "${NC}"

    # Show live stats
    echo -e "${BOLD}Live Status${NC}"
    echo ""

    # Health check
    local index_ok=false
    local status_ok=false
    local redis_ok=false

    curl -s --connect-timeout 1 "http://localhost:8080/health" > /dev/null 2>&1 && index_ok=true
    curl -s --connect-timeout 1 "http://localhost:8080/status" > /dev/null 2>&1 && status_ok=true

    # Check Redis (works in both unified and compose modes)
    if docker exec aoa redis-cli ping > /dev/null 2>&1; then
        redis_ok=true
    elif docker exec aoa-redis-1 redis-cli ping > /dev/null 2>&1; then
        redis_ok=true
    fi

    if $index_ok; then
        echo -e "  Index:  ${GREEN}‚úì${NC} Running"
    else
        echo -e "  Index:  ${RED}‚úó${NC} Not responding"
    fi

    if $status_ok; then
        echo -e "  Status: ${GREEN}‚úì${NC} Running"
    else
        echo -e "  Status: ${RED}‚úó${NC} Not responding"
    fi

    if $redis_ok; then
        echo -e "  Redis:  ${GREEN}‚úì${NC} Connected"
    else
        echo -e "  Redis:  ${RED}‚úó${NC} Not connected"
    fi

    echo ""

    # Quick stats
    local memory_result=$(curl -s "http://localhost:8080/memory?format=compact" 2>/dev/null)
    if [ -n "$memory_result" ]; then
        local files=$(echo "$memory_result" | jq -r '.files_analyzed' 2>/dev/null)
        local ms=$(echo "$memory_result" | jq -r '.ms' 2>/dev/null)
        echo -e "  Memory: ${files} active files, ${GREEN}${ms}ms${NC} latency"
    fi

    local health_result=$(curl -s "http://localhost:8080/health" 2>/dev/null)
    if [ -n "$health_result" ]; then
        local symbols=$(echo "$health_result" | jq -r '.local.symbols' 2>/dev/null)
        local idx_files=$(echo "$health_result" | jq -r '.local.files' 2>/dev/null)
        echo -e "  Index:  ${idx_files} files, ${symbols} symbols"
    fi
}

cmd_memory() {
    local format="${1:-prose}"

    case "$format" in
        -c|--compact|compact)
            format="compact"
            ;;
        -s|--structured|structured|json)
            format="structured"
            ;;
        -p|--prose|prose|*)
            format="prose"
            ;;
    esac

    local result=$(curl -s "http://localhost:8080/memory?format=${format}")

    if [ "$format" = "structured" ]; then
        echo "$result" | jq .
    else
        local memory=$(echo "$result" | jq -r '.memory')
        local ms=$(echo "$result" | jq -r '.ms')
        local files=$(echo "$result" | jq -r '.files_analyzed')

        echo -e "${CYAN}${BOLD}‚ö° aOa Working Memory${NC} ${DIM}‚îÇ${NC} ${files} files ${DIM}‚îÇ${NC} ${GREEN}${ms}ms${NC}"
        echo ""
        echo "$memory"
    fi
}

cmd_health() {
    echo -e "${BOLD}aOa Angles${NC}"
    echo ""

    # Check index service (Symbol + Intent angles)
    echo -n "Symbol/Intent (${INDEX_URL}): "
    if curl -s --connect-timeout 2 "${INDEX_URL}/health" > /dev/null 2>&1; then
        local idx_health=$(curl -s "${INDEX_URL}/health")
        local mode=$(echo "$idx_health" | jq -r '.mode // "legacy"')

        # Handle both legacy and global modes
        if [ "$mode" = "global" ]; then
            local project_count=$(echo "$idx_health" | jq '.projects | length // 0')
            if [ "$project_count" -gt 0 ]; then
                echo -e "${GREEN}‚úì${NC} ${project_count} project(s) indexed (global mode)"
            else
                echo -e "${YELLOW}!${NC} Global mode ${DIM}(no projects registered - run 'aoa init')${NC}"
            fi
        else
            # Legacy mode
            local local_files=$(echo "$idx_health" | jq -r '.local.files // 0')
            local local_symbols=$(echo "$idx_health" | jq -r '.local.symbols // 0')
            echo -e "${GREEN}‚úì${NC} ${local_files} files, ${local_symbols} symbols (local)"
        fi

        local repo_count=$(echo "$idx_health" | jq '.repos | length // 0')
        if [ "$repo_count" != "0" ] && [ "$repo_count" != "null" ]; then
            echo -e "                              ${DIM}+ ${repo_count} knowledge repos${NC}"
        fi
    else
        echo -e "${RED}‚úó Not running${NC}"
    fi

    # Check status service (Strike angle metrics)
    echo -n "Strike/Metrics (${STATUS_URL}): "
    if curl -s --connect-timeout 2 "${STATUS_URL}/health" > /dev/null 2>&1; then
        echo -e "${GREEN}‚úì${NC} Running"
    else
        echo -e "${RED}‚úó Not running${NC}"
    fi

    # Check Redis (predictions, scores)
    echo -n "Redis (predictions): "
    if curl -s --connect-timeout 2 "${STATUS_URL}/session" > /dev/null 2>&1; then
        echo -e "${GREEN}‚úì${NC} Connected"
    else
        echo -e "${YELLOW}? Unknown${NC}"
    fi
}

cmd_baseline() {
    echo -e "${BOLD}aOa Baseline Costs${NC}"
    echo -e "${DIM}Subagent activity tracked from session logs${NC}"
    echo

    local result=$(curl -s "${STATUS_URL}/baseline" 2>/dev/null)

    if [ -z "$result" ]; then
        echo -e "${RED}Could not connect to status service${NC}"
        return 1
    fi

    local total_tokens=$(echo "$result" | jq -r '.baseline.total_tokens // 0')
    local tool_calls=$(echo "$result" | jq -r '.baseline.tool_calls // 0')
    local search_tools=$(echo "$result" | jq -r '.baseline.search_tools // 0')
    local potential_savings=$(echo "$result" | jq -r '.baseline.potential_savings_tokens // 0')
    local last_sync=$(echo "$result" | jq -r '.baseline.last_sync // 0')

    if [ "$total_tokens" -eq 0 ]; then
        echo -e "${DIM}No baseline data yet.${NC}"
        echo -e "${DIM}Subagent sync runs automatically in the background.${NC}"
        return 0
    fi

    # Format tokens
    format_k() {
        local n=$1
        if [ "$n" -ge 1000 ]; then
            echo "$((n / 1000))k"
        else
            echo "$n"
        fi
    }

    local tokens_fmt=$(format_k $total_tokens)
    local savings_fmt=$(format_k $potential_savings)

    echo -e "  ${BOLD}Subagent Activity Observed:${NC}"
    echo -e "    Tool calls: ${CYAN}${tool_calls}${NC}"
    echo -e "    Tokens: ${CYAN}${tokens_fmt}${NC}"
    echo -e "    Grep/Glob used: ${YELLOW}${search_tools}${NC} times"
    echo

    if [ "$potential_savings" -gt 0 ]; then
        local pct=$((potential_savings * 100 / total_tokens))
        echo -e "  ${BOLD}Potential Savings with aOa:${NC}"
        echo -e "    Tokens: ${GREEN}‚Üì${savings_fmt}${NC} ${DIM}(~${pct}% of subagent tokens)${NC}"
        echo -e "    Tool calls: ${GREEN}‚Üì${search_tools}${NC} ${DIM}Grep/Glob ‚Üí aoa search${NC}"
        echo
    fi

    if [ "$last_sync" -gt 0 ]; then
        local now=$(date +%s)
        local age=$((now - last_sync))
        echo -e "  ${DIM}Last sync: ${age}s ago${NC}"
    fi
    echo
}

cmd_metrics() {
    local project_id=$(get_project_id)
    local metrics=$(curl -s --connect-timeout 2 "${INDEX_URL}/metrics?project_id=${project_id}" 2>/dev/null)

    if [ -z "$metrics" ] || echo "$metrics" | jq -e '.error' > /dev/null 2>&1; then
        echo -e "${RED}Metrics not available${NC}"
        return 1
    fi

    # Parse metrics
    local hit_pct=$(echo "$metrics" | jq -r '.rolling.hit_at_5_pct // 0')
    local evaluated=$(echo "$metrics" | jq -r '.rolling.evaluated // 0')
    local hits=$(echo "$metrics" | jq -r '.rolling.hits // 0')
    local tokens_saved=$(echo "$metrics" | jq -r '.savings.tokens // 0')
    local time_saved=$(echo "$metrics" | jq -r '.savings.time_sec // 0')
    local trend=$(echo "$metrics" | jq -r '.trend // "unknown"')

    # Format hit percentage
    local hit_int=$(printf "%.0f" "$hit_pct")

    # Traffic light
    local color=$GREEN
    local light="üü¢"
    if [ "$evaluated" -lt 3 ]; then
        color=$DIM
        light="‚ö™"
    elif [ "$hit_int" -lt 80 ]; then
        color=$YELLOW
        light="üü°"
    fi

    echo -e "${BOLD}aOa Prediction Metrics${NC}"
    echo ""
    echo -e "  Accuracy:     ${color}${light} ${hit_int}%${NC} ${DIM}(${evaluated} evaluated)${NC}"
    echo -e "  Hits:         ${hits}"
    echo -e "  Trend:        ${trend}"
    echo ""
    echo -e "${BOLD}Savings${NC}"
    echo -e "  Tokens:       ${GREEN}‚Üì${tokens_saved}${NC}"
    echo -e "  Time:         ${GREEN}‚ö°${time_saved}s${NC}"
    echo ""
    echo -e "${DIM}Full JSON: aoa metrics --json${NC}"

    # Handle --json flag
    if [[ "${1:-}" == "--json" ]] || [[ "${1:-}" == "-j" ]]; then
        echo ""
        echo "$metrics" | jq .
    fi
}

cmd_history() {
    local limit="${1:-20}"

    curl -s "${STATUS_URL}/history?limit=${limit}" | jq -r '.events[] |
        if .type == "request" then
            "[\(.ts | strftime("%H:%M:%S"))] \(.model) in:\(.input) out:\(.output) $\(.cost)"
        elif .type == "model_switch" then
            "[\(.ts | strftime("%H:%M:%S"))] -> \(.model)"
        elif .type == "block" then
            "[\(.ts | strftime("%H:%M:%S"))] BLOCKED \(.block_type)"
        else
            "[\(.ts | strftime("%H:%M:%S"))] \(.type)"
        end
    '
}

cmd_reset() {
    local target="${1:-session}"

    case "$target" in
        session)
            curl -s -X POST "${STATUS_URL}/session/reset" | jq .
            echo -e "${GREEN}Session reset${NC}"
            ;;
        weekly)
            curl -s -X POST "${STATUS_URL}/weekly/reset" | jq .
            echo -e "${GREEN}Weekly stats reset${NC}"
            ;;
        *)
            echo "Usage: aoa reset [session|weekly]"
            return 1
            ;;
    esac
}

cmd_whitelist() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)
            curl -s "${INDEX_URL}/git/whitelist" | jq -r '
                "Default hosts:", (.default_hosts[] | "  \(.)"),
                "", "Custom hosts:",
                (if .custom_hosts | length > 0 then (.custom_hosts[] | "  \(.)") else "  (none)" end)
            '
            ;;
        add)
            local host="$1"
            if [ -z "$host" ]; then
                echo "Usage: aoa whitelist add <host>"
                echo "Example: aoa whitelist add git.company.com"
                return 1
            fi
            curl -s -X POST "${INDEX_URL}/git/whitelist" \
                -H "Content-Type: application/json" \
                -d "{\"host\": \"${host}\"}" | jq .
            ;;
        remove|rm)
            local host="$1"
            if [ -z "$host" ]; then
                echo "Usage: aoa whitelist remove <host>"
                return 1
            fi
            curl -s -X DELETE "${INDEX_URL}/git/whitelist/${host}" | jq .
            ;;
        *)
            echo -e "${BOLD}Whitelist Management${NC}"
            echo ""
            echo "Commands:"
            echo "  aoa whitelist list         Show allowed URLs"
            echo "  aoa whitelist add <host>   Add URL to whitelist"
            echo "  aoa whitelist remove <h>   Remove URL from whitelist"
            echo ""
            echo "Examples:"
            echo "  aoa whitelist add git.company.com"
            echo "  aoa whitelist add docs.internal.org"
            ;;
    esac
}

cmd_help() {
    cat << 'EOF'
                              AOA
                       5 angles. 1 attack.

GETTING STARTED
  ./install.sh           Install aOa globally (once)
  aoa init               Enable aOa in current project
  aoa remove             Disable aOa in current project
  aoa projects           List all enabled projects

PROJECT SEARCH
  search <term>          O(1) symbol lookup (current project)
  multi <t1,t2,...>      Multi-angle search
  changes [time]         Recent file changes (e.g., 5m, 1h)
  files [pattern]        List indexed files

OUTLINE ANGLE (code structure)
  outline <file>         Code outline via tree-sitter (functions, classes)
  outline <f> --enrich   Request AI enrichment (Claude spawns Haiku)
  outline --enrich-all   Batch enrich project (delta: only changed files)

ATTACK STATUS
  status                 Show attack status (hit rate, intents)
  status --watch         Live updating status
  status --json          Full metrics as JSON
  history [limit]        Recent events
  reset [session|weekly] Reset counters

SIGNAL ANGLE (pattern matching)
  pattern '<json>'       Multi-pattern regex search
    --repo <name>        Search in specific repo
    --since <time>       Only files modified recently (e.g., 7d)

INTENT ANGLE (behavioral tracking)
  intent recent [since]  Recent intent records (e.g., 1h, 30m)
  intent tags            All tags with file counts
  intent files <tag>     Files associated with an intent tag
  intent file <path>     Tags associated with a file
  intent stats           Intent index statistics

INTEL ANGLE (external reference)
  repo list              List intel sources
  repo add <name> <url>  Clone and index a git repo
  repo remove <name>     Remove an intel source
  repo <name> search <t> Search in a specific repo

SYSTEM
  health                 Check all angles
  metrics                Prediction accuracy and savings
  baseline               Subagent baseline costs and potential savings
  services               Visual service map with live status

EXAMPLES
  # First time setup
  ./install.sh                  # Install globally (once)
  cd ~/my-project && aoa init   # Enable for project

  # Search your project
  aoa search handleAuth
  aoa multi auth,session,token

  # Add reference repos
  aoa repo add flask https://github.com/pallets/flask
  aoa repo flask search Blueprint

ARCHITECTURE
  ~/.aoa/                Global installation
  .claude/hooks/         Per-project hooks (created by aoa init)

  Install once ‚Üí enable per-project ‚Üí search anywhere

EOF
}

# =============================================================================
# Main
# =============================================================================

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        # Project Management (new in v2)
        init)       cmd_init "$@" ;;
        remove|rm)  cmd_remove "$@" ;;
        projects)   cmd_projects "$@" ;;

        # Status
        status|s)   cmd_status "$@" ;;
        history|h)  cmd_history "$@" ;;
        reset)      cmd_reset "$@" ;;

        # Local Index
        search)     cmd_search "$@" ;;
        multi|m)    cmd_multi "$@" ;;
        changes|c)  cmd_changes "$@" ;;
        files|f)    cmd_files "$@" ;;
        outline|o)  cmd_outline "$@" ;;

        # Pattern Search
        pattern|p)  cmd_pattern "$@" ;;

        # Intent Tracking
        intent|i)   cmd_intent "$@" ;;

        # Whitelist Management
        whitelist|w) cmd_whitelist "$@" ;;

        # Knowledge Repos
        repo|r)     cmd_repo "$@" ;;

        # System
        health)     cmd_health ;;
        metrics)    cmd_metrics ;;
        baseline|bl) cmd_baseline ;;
        memory|mem) cmd_memory "$@" ;;
        services|svc|map) cmd_services ;;
        help|--help|-h) cmd_help ;;

        *)
            echo -e "${RED}Unknown command: $cmd${NC}"
            echo "Run 'aoa help' for usage"
            return 1
            ;;
    esac
}

main "$@"
