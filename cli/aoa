#!/usr/bin/env bash
# aoa - 5 angles. 1 attack.
#
# Global Installation:
#   ./install.sh            Install aOa globally to ~/.aoa/
#
# Per-Project:
#   aoa init                Enable aOa for current project
#   aoa remove              Disable aOa for current project
#   aoa projects            List all enabled projects
#
# Search (after init):
#   aoa search <term>       Search current project
#   aoa multi <t1,t2,...>   Multi-term search
#   aoa health              Check services

set -e

# Configuration
GATEWAY_HOST="${AOA_GATEWAY_HOST:-localhost}"
GATEWAY_PORT="${AOA_GATEWAY_PORT:-8080}"

# Find AOA_HOME by locating the CLI script itself
CLI_PATH="$(readlink -f "$0")"
AOA_HOME="$(dirname "$(dirname "$CLI_PATH")")"
AOA_DATA="${AOA_DATA:-$AOA_HOME/data}"

INDEX_URL="http://${GATEWAY_HOST}:${GATEWAY_PORT}"
STATUS_URL="http://${GATEWAY_HOST}:${GATEWAY_PORT}"

# Colors
BOLD='\033[1m'
DIM='\033[2m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
RED='\033[0;31m'
NC='\033[0m'

# =============================================================================
# Project Management Commands
# =============================================================================

# Get project ID from .aoa/home.json (UUID generated at init)
get_project_id() {
    local project_root=$(get_project_root)
    if [ -z "$project_root" ]; then
        echo ""
        return
    fi

    local home_file="$project_root/.aoa/home.json"
    if [ -f "$home_file" ]; then
        jq -r '.project_id // empty' "$home_file" 2>/dev/null
    fi
}

# Generate a new UUID for project identification
generate_project_id() {
    # Try uuidgen first (Linux/macOS), fall back to Python
    if command -v uuidgen > /dev/null 2>&1; then
        uuidgen | tr '[:upper:]' '[:lower:]'
    else
        python3 -c "import uuid; print(uuid.uuid4())"
    fi
}

# Get project root
get_project_root() {
    git rev-parse --show-toplevel 2>/dev/null
}

# Get project name
get_project_name() {
    local root=$(get_project_root)
    if [ -n "$root" ]; then
        basename "$root"
    fi
}

cmd_init() {
    echo -e "${CYAN}${BOLD}⚡ aOa - Initializing Project${NC}"
    echo

    # Check if aOa is installed globally
    if [ ! -d "$AOA_HOME" ]; then
        echo -e "${RED}aOa not installed globally.${NC}"
        echo -e "${DIM}Run ./install.sh from the aOa repository first.${NC}"
        return 1
    fi

    # Check if we're in a git repo
    local project_root=$(get_project_root)
    if [ -z "$project_root" ]; then
        echo -e "${RED}Not in a git repository.${NC}"
        echo -e "${DIM}aOa requires a git repo to detect project boundaries.${NC}"
        return 1
    fi

    local project_name=$(get_project_name)

    # Check if already has a project_id, otherwise generate new one
    local existing_id=$(get_project_id)
    local project_id="${existing_id:-$(generate_project_id)}"

    echo -e "  Project: ${BOLD}${project_name}${NC}"
    echo -e "  Path:    ${DIM}${project_root}${NC}"
    echo -e "  ID:      ${DIM}${project_id}${NC}"
    echo

    # Check if already initialized
    if [ -f "$project_root/.claude/hooks/aoa-status-line.sh" ]; then
        echo -e "${YELLOW}Project already initialized.${NC}"
        echo -e "${DIM}Run 'aoa remove' first to reinitialize.${NC}"
        return 0
    fi

    # Create .claude directories
    mkdir -p "$project_root/.claude/hooks"
    mkdir -p "$project_root/.claude/skills"

    # Copy hooks from templates
    echo -n "  Installing hooks.............. "
    cp "$AOA_HOME/plugin/hooks/"*.py "$project_root/.claude/hooks/" 2>/dev/null || true
    cp "$AOA_HOME/plugin/hooks/"*.sh "$project_root/.claude/hooks/" 2>/dev/null || true
    chmod +x "$project_root/.claude/hooks/"*.py "$project_root/.claude/hooks/"*.sh 2>/dev/null || true
    echo -e "${GREEN}✓${NC}"

    # Copy skills (directory-based structure for Claude Code)
    echo -n "  Installing skills............. "
    for skill_dir in "$AOA_HOME/plugin/skills/"*/; do
        if [ -d "$skill_dir" ]; then
            cp -r "$skill_dir" "$project_root/.claude/skills/" 2>/dev/null || true
        fi
    done
    echo -e "${GREEN}✓${NC}"

    # Copy agents
    echo -n "  Installing agents............. "
    mkdir -p "$project_root/.claude/agents"
    cp "$AOA_HOME/plugin/agents/"*.md "$project_root/.claude/agents/" 2>/dev/null || true
    echo -e "${GREEN}✓${NC}"

    # Create .aoa/ folder with home pointer
    echo -n "  Creating .aoa/ config......... "
    mkdir -p "$project_root/.aoa"

    # home.json - project config with UUID identifier
    cat > "$project_root/.aoa/home.json" << EOFHOME
{
  "aoa_home": "$AOA_HOME",
  "data_dir": "$AOA_DATA",
  "project_id": "$project_id",
  "project_root": "$project_root"
}
EOFHOME

    # whitelist.txt - optional repos/URLs for this project
    if [ ! -f "$project_root/.aoa/whitelist.txt" ]; then
        cat > "$project_root/.aoa/whitelist.txt" << 'EOFWHITELIST'
# aOa Whitelist - URLs allowed for this project
# Add one domain per line (HTTPS only)
#
# Examples:
# github.com/your-org/repo
# docs.your-company.com
# internal-git.example.com
EOFWHITELIST
    fi

    # README.md - explains the folder (only if not present)
    if [ ! -f "$project_root/.aoa/README.md" ]; then
        cat > "$project_root/.aoa/README.md" << 'EOFREADME'
# .aoa - aOa Project Link

This folder links this project to your global aOa installation.

## Files

| File | Purpose |
|------|---------|
| `home.json` | Points to global aOa install location |
| `whitelist.txt` | Optional: extra URLs/repos for this project |

## What is aOa?

aOa (Angle of Attack) provides fast O(1) code search for Claude Code.
It replaces slow Grep/Glob operations with indexed symbol lookup.

## Commands

```bash
aoa search <term>    # Search this project
aoa health           # Check services
aoa remove           # Remove aOa from this project
```

## Global Settings

To change aOa settings (port, confidence threshold, etc.),
edit the config.json in your global aOa installation.
EOFREADME
    fi

    # Copy USAGE.md - goal-oriented guide for Claude
    cp "$AOA_HOME/plugin/USAGE.md" "$project_root/.aoa/USAGE.md" 2>/dev/null || true
    echo -e "${GREEN}✓${NC}"

    # Add aOa reference to CLAUDE.md
    echo -n "  Updating CLAUDE.md............ "
    local claude_md="$project_root/CLAUDE.md"
    local aoa_marker="# aOa Integration"

    if [ -f "$claude_md" ]; then
        # Check if already has aOa section
        if ! grep -q "$aoa_marker" "$claude_md" 2>/dev/null; then
            # Append aOa reference
            cat >> "$claude_md" << 'EOFCLAUDE'

# aOa Integration

**Why:** aOa provides O(1) symbol search. Instead of slow Grep/Glob, find code in <5ms.

**Commands:**
- `aoa search <term>` - Find code fast (ALWAYS use instead of Grep)
- `aoa outline <file>` - See file structure without reading it all
- `aoa intent` - Track what you're working on

**Rule:** Use `aoa` CLI, never raw curl. See `.aoa/USAGE.md` for full guide.
EOFCLAUDE
            echo -e "${GREEN}✓${NC} ${DIM}(appended)${NC}"
        else
            echo -e "${YELLOW}✓${NC} ${DIM}(already present)${NC}"
        fi
    else
        # Create minimal CLAUDE.md with aOa section
        cat > "$claude_md" << 'EOFCLAUDE'
# aOa Integration

**Why:** aOa provides O(1) symbol search. Instead of slow Grep/Glob, find code in <5ms.

**Commands:**
- `aoa search <term>` - Find code fast (ALWAYS use instead of Grep)
- `aoa outline <file>` - See file structure without reading it all
- `aoa intent` - Track what you're working on

**Rule:** Use `aoa` CLI, never raw curl. See `.aoa/USAGE.md` for full guide.
EOFCLAUDE
        echo -e "${GREEN}✓${NC} ${DIM}(created)${NC}"
    fi

    # Copy or merge settings template
    echo -n "  Merging settings.............. "
    if [ ! -f "$project_root/.claude/settings.local.json" ]; then
        # No existing settings - copy template
        cp "$AOA_DATA/settings.template.json" "$project_root/.claude/settings.local.json"
        echo -e "${GREEN}✓${NC}"
    else
        # Backup existing settings
        cp "$project_root/.claude/settings.local.json" \
           "$project_root/.claude/settings.local.json.pre-aoa-$(date +%Y%m%d-%H%M%S)"

        # Deep merge: preserve their settings, add our hooks/statusLine/permissions
        jq -s '
            # Start with their settings (index 1)
            .[1] as $existing |
            # Our template (index 0)
            .[0] as $template |

            # Merge strategy:
            # - permissions.allow: union (combine both)
            # - hooks: merge by type (combine hook arrays)
            # - statusLine: use ours if missing
            # - everything else: preserve theirs

            $existing |
            # Add our statusLine if missing
            (if .statusLine == null then .statusLine = $template.statusLine else . end) |
            # Merge permissions.allow
            (if .permissions.allow then
                .permissions.allow += $template.permissions.allow | .permissions.allow |= unique
             else
                .permissions = $template.permissions
             end) |
            # Merge hooks (deep merge by hook type)
            (if .hooks then
                .hooks = ($template.hooks * .hooks)
             else
                .hooks = $template.hooks
             end)
        ' "$AOA_DATA/settings.template.json" "$project_root/.claude/settings.local.json" \
          > "$project_root/.claude/settings.local.json.new"

        mv "$project_root/.claude/settings.local.json.new" "$project_root/.claude/settings.local.json"
        echo -e "${GREEN}✓${NC} ${DIM}(merged, backup created)${NC}"
    fi

    # Register project in projects.json
    echo -n "  Registering project........... "
    local projects_file="$AOA_DATA/projects.json"
    local now=$(date -Iseconds)

    # Create entry
    local entry=$(jq -n \
        --arg id "$project_id" \
        --arg name "$project_name" \
        --arg path "$project_root" \
        --arg added "$now" \
        '{id: $id, name: $name, path: $path, added: $added}')

    # Add to projects.json (remove existing entry with same id first)
    local updated=$(jq --arg id "$project_id" 'map(select(.id != $id))' "$projects_file")
    echo "$updated" | jq --argjson entry "$entry" '. + [$entry]' > "$projects_file.tmp"
    mv "$projects_file.tmp" "$projects_file"
    echo -e "${GREEN}✓${NC}"

    # Trigger initial index
    echo -n "  Indexing project.............. "
    local index_result=$(curl -s -X POST "${INDEX_URL}/project/register" \
        -H "Content-Type: application/json" \
        -d "{\"id\": \"${project_id}\", \"name\": \"${project_name}\", \"path\": \"${project_root}\"}" 2>/dev/null)

    if echo "$index_result" | jq -e '.success' > /dev/null 2>&1; then
        local file_count=$(echo "$index_result" | jq -r '.files // 0')
        echo -e "${GREEN}✓${NC} ${DIM}(${file_count} files)${NC}"
    else
        echo -e "${YELLOW}pending${NC} ${DIM}(will index on first search)${NC}"
    fi

    echo
    echo -e "${GREEN}${BOLD}✓ aOa enabled for ${project_name}${NC}"
    echo
    echo -e "${DIM}Restart Claude Code to activate hooks.${NC}"
    echo -e "${DIM}Then try: aoa search <term>${NC}"
    echo
}

cmd_remove() {
    echo -e "${CYAN}${BOLD}⚡ aOa - Removing from Project${NC}"
    echo

    local project_root=$(get_project_root)
    if [ -z "$project_root" ]; then
        echo -e "${RED}Not in a git repository.${NC}"
        return 1
    fi

    local project_id=$(get_project_id)
    local project_name=$(get_project_name)

    echo -e "  Project: ${BOLD}${project_name}${NC}"
    echo

    # Check if initialized
    if [ ! -f "$project_root/.claude/hooks/aoa-status-line.sh" ]; then
        echo -e "${DIM}aOa not initialized in this project.${NC}"
        return 0
    fi

    # Remove hooks
    echo -n "  Removing hooks................ "
    rm -f "$project_root/.claude/hooks/aoa-"* 2>/dev/null || true
    echo -e "${GREEN}✓${NC}"

    # Remove skills (all aoa* folders and files)
    echo -n "  Removing skills............... "
    rm -rf "$project_root/.claude/skills/aoa"* 2>/dev/null || true
    echo -e "${GREEN}✓${NC}"

    # Remove agents
    echo -n "  Removing agents............... "
    rm -f "$project_root/.claude/agents/aoa-"* 2>/dev/null || true
    echo -e "${GREEN}✓${NC}"

    # Remove entire .aoa/ folder (full cleanup)
    echo -n "  Removing .aoa/ folder......... "
    rm -rf "$project_root/.aoa" 2>/dev/null || true
    echo -e "${GREEN}✓${NC}"

    # Remove from projects.json
    echo -n "  Unregistering project......... "
    local projects_file="$AOA_DATA/projects.json"
    if [ -f "$projects_file" ]; then
        jq --arg id "$project_id" 'map(select(.id != $id))' "$projects_file" > "$projects_file.tmp"
        mv "$projects_file.tmp" "$projects_file"
    fi
    echo -e "${GREEN}✓${NC}"

    # Notify service to remove index
    echo -n "  Removing index................ "
    curl -s -X DELETE "${INDEX_URL}/project/${project_id}" > /dev/null 2>&1 || true
    echo -e "${GREEN}✓${NC}"

    # Clean up CLAUDE.md - remove aOa Integration section
    echo -n "  Cleaning CLAUDE.md............ "
    local claude_md="$project_root/CLAUDE.md"
    if [ -f "$claude_md" ] && grep -q "# aOa Integration" "$claude_md"; then
        # Remove the aOa Integration section (from marker to next # heading or EOF)
        sed -i '/^# aOa Integration$/,/^# [^a]/{/^# [^a]/!d}' "$claude_md" 2>/dev/null
        # Clean up any trailing empty lines
        sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$claude_md" 2>/dev/null
        echo -e "${GREEN}✓${NC}"
    else
        echo -e "${DIM}not present${NC}"
    fi

    # Restore settings from backup if available
    echo -n "  Restoring settings............ "
    # Find the most recent backup
    local backup=$(ls -t "$project_root/.claude/settings.local.json.pre-aoa-"* 2>/dev/null | head -1)

    if [ -f "$project_root/.claude/settings.local.json" ]; then
        if [ -n "$backup" ]; then
            # Backup exists - restore original settings
            mv "$backup" "$project_root/.claude/settings.local.json"
            # Clean up any other backups
            rm -f "$project_root/.claude/settings.local.json.pre-aoa-"* 2>/dev/null
            echo -e "${GREEN}restored from backup${NC}"
        else
            # No backup - check if it's just our template
            local template_hash=$(md5sum "$AOA_DATA/settings.template.json" 2>/dev/null | cut -d' ' -f1)
            local settings_hash=$(md5sum "$project_root/.claude/settings.local.json" 2>/dev/null | cut -d' ' -f1)

            if [ "$template_hash" = "$settings_hash" ]; then
                rm -f "$project_root/.claude/settings.local.json"
                echo -e "${GREEN}removed${NC}"
            else
                echo -e "${YELLOW}preserved (has customizations)${NC}"
            fi
        fi
    else
        echo -e "${DIM}not found${NC}"
    fi

    # Clean up empty directories
    echo -n "  Cleaning directories.......... "
    rmdir "$project_root/.claude/hooks" 2>/dev/null || true
    rmdir "$project_root/.claude/skills" 2>/dev/null || true
    rmdir "$project_root/.claude/agents" 2>/dev/null || true
    rmdir "$project_root/.claude" 2>/dev/null || true
    echo -e "${GREEN}✓${NC}"

    echo
    echo -e "${GREEN}${BOLD}✓ aOa removed from ${project_name}${NC}"
    echo
    echo -e "${DIM}Restart Claude Code to deactivate hooks.${NC}"
    echo
}

cmd_projects() {
    echo -e "${BOLD}aOa Projects${NC}"
    echo

    local projects_file="$AOA_DATA/projects.json"

    if [ ! -f "$projects_file" ]; then
        echo -e "${DIM}No projects registered.${NC}"
        echo -e "${DIM}Run 'aoa init' in a project to enable aOa.${NC}"
        return 0
    fi

    local count=$(jq 'length' "$projects_file" 2>/dev/null)

    if [ "$count" = "0" ] || [ -z "$count" ]; then
        echo -e "${DIM}No projects registered.${NC}"
        echo -e "${DIM}Run 'aoa init' in a project to enable aOa.${NC}"
        return 0
    fi

    # Get current project for highlighting
    local current_id=$(get_project_id)

    # List projects
    jq -r '.[] | "\(.id)|\(.name)|\(.path)"' "$projects_file" | while IFS='|' read -r id name path; do
        if [ "$id" = "$current_id" ]; then
            echo -e "  ${GREEN}▸${NC} ${BOLD}${name}${NC} ${DIM}${path}${NC} ${GREEN}(current)${NC}"
        else
            # Check if path still exists
            if [ -d "$path" ]; then
                echo -e "  ${DIM}•${NC} ${name} ${DIM}${path}${NC}"
            else
                echo -e "  ${RED}✗${NC} ${name} ${DIM}${path}${NC} ${RED}(missing)${NC}"
            fi
        fi
    done

    echo
    echo -e "${DIM}${count} project(s) registered${NC}"
}

# =============================================================================
# Local Index Commands (default)
# =============================================================================

cmd_search() {
    local query="$1"
    local mode="${2:-recent}"
    local limit="${3:-20}"

    if [ -z "$query" ]; then
        echo "Usage: aoa search <term> [mode] [limit]"
        return 1
    fi

    # URL-encode the query (handles #, spaces, etc.)
    local encoded_query=$(printf '%s' "$query" | jq -sRr @uri)

    # Get current project context
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/symbol?q=${encoded_query}&mode=${mode}&limit=${limit}${project_param}")
    local ms=$(echo "$result" | jq -r '.ms // 0')
    local count=$(echo "$result" | jq -r '.results | length')

    # Single punchy line: ⚡ 7 hits │ 0.12ms
    printf "${CYAN}${BOLD}⚡ %s hits${NC} ${DIM}│${NC} ${GREEN}%.2fms${NC}\n" "$count" "$ms"

    # Results - show symbol metadata when available (for semantic compression tags)
    echo "$result" | jq -r '.results[] |
      if .symbol then
        "  \(.file):\(.line) \(.symbol_kind // ""):\(.symbol) [\(.line)-\(.end_line // .line)]"
      else
        "  \(.file):\(.line)"
      end' 2>/dev/null
}

cmd_multi() {
    local terms="$1"
    local mode="${2:-recent}"
    local limit="${3:-20}"

    if [ -z "$terms" ]; then
        echo "Usage: aoa multi <term1,term2,...> [mode] [limit]"
        return 1
    fi

    # Get current project context
    local project_id=$(get_project_id)

    # Convert to JSON array
    local json_terms=$(echo "$terms" | tr ',' '\n' | jq -R . | jq -s .)

    local body="{\"terms\": ${json_terms}, \"mode\": \"${mode}\", \"limit\": ${limit}"
    if [ -n "$project_id" ]; then
        body="${body}, \"project\": \"${project_id}\""
    fi
    body="${body}}"

    local result=$(curl -s -X POST "${INDEX_URL}/multi" \
        -H "Content-Type: application/json" \
        -d "$body")

    local ms=$(echo "$result" | jq -r '.ms // 0')
    local count=$(echo "$result" | jq -r '.results | length')

    # Single punchy line
    printf "${CYAN}${BOLD}⚡ %s hits${NC} ${DIM}│${NC} ${GREEN}%.2fms${NC}\n" "$count" "$ms"

    echo "$result" | jq -r '.results[] | "  \(.file):\(.line)"' 2>/dev/null
}

cmd_changes() {
    local since="${1:-300}"
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    # Parse time strings
    if [[ "$since" =~ ^([0-9]+)([smh])$ ]]; then
        local num="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2]}"
        case "$unit" in
            s) since=$num ;;
            m) since=$((num * 60)) ;;
            h) since=$((num * 3600)) ;;
        esac
    fi

    local result=$(curl -s "${INDEX_URL}/changes?since=${since}${project_param}")

    echo -e "${GREEN}Added:${NC}"
    echo "$result" | jq -r '.added[]' 2>/dev/null || echo "  (none)"

    echo -e "${YELLOW}Modified:${NC}"
    echo "$result" | jq -r '.modified[].file' 2>/dev/null || echo "  (none)"

    echo -e "${RED}Deleted:${NC}"
    echo "$result" | jq -r '.deleted[]' 2>/dev/null || echo "  (none)"
}

cmd_files() {
    local pattern="$1"
    local mode="${2:-recent}"
    local limit="${3:-30}"

    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local url="${INDEX_URL}/files?mode=${mode}&limit=${limit}${project_param}"
    [ -n "$pattern" ] && url="${url}&match=${pattern}"

    curl -s "$url" | jq -r '.results[] | "\(.path) (\(.language))"'
}

cmd_outline() {
    local file=""
    local enrich=false
    local enrich_all=false
    local pending=false
    local json_output=false
    local store=false
    local show_tags=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --enrich)
                enrich=true
                shift
                ;;
            --enrich-all)
                enrich_all=true
                shift
                ;;
            --pending)
                pending=true
                shift
                ;;
            --json|-j)
                json_output=true
                shift
                ;;
            --store)
                store=true
                shift
                ;;
            --tags|-t)
                show_tags=true
                shift
                ;;
            -*)
                echo "Unknown option: $1"
                return 1
                ;;
            *)
                file="$1"
                shift
                ;;
        esac
    done

    # Handle --store (post enriched tags from stdin)
    if $store; then
        local project_id=$(get_project_id)
        local json_input=$(cat)

        # Add project_id if not present
        if [ -n "$project_id" ]; then
            json_input=$(echo "$json_input" | jq --arg pid "$project_id" '. + {project: $pid}')
        fi

        local result=$(echo "$json_input" | curl -s -X POST "${INDEX_URL}/outline/enriched" \
            -H "Content-Type: application/json" \
            -d @-)

        if $json_output; then
            echo "$result" | jq .
        else
            local success=$(echo "$result" | jq -r '.success // false')
            if [ "$success" = "true" ]; then
                local tags_count=$(echo "$result" | jq -r '.tags_indexed // 0')
                local symbols_count=$(echo "$result" | jq -r '.symbols_processed // 0')
                echo -e "${GREEN}✓${NC} Stored ${tags_count} tags across ${symbols_count} symbols"

                # Record to intent system for activity tracking
                local file_path=$(echo "$json_input" | jq -r '.file // ""')
                local tags=$(echo "$json_input" | jq -c '[.symbols[].tags[]?] | unique | .[0:5]')
                if [ -n "$file_path" ] && [ "$tags" != "[]" ]; then
                    curl -s -X POST "${INDEX_URL}/intent" \
                        -H "Content-Type: application/json" \
                        -d "{\"tool\": \"Outline\", \"files\": [\"$file_path\"], \"tags\": $tags, \"project_id\": \"$project_id\"}" > /dev/null 2>&1
                fi
            else
                local err=$(echo "$result" | jq -r '.error // "Unknown error"')
                echo -e "${RED}✗${NC} ${err}"
                return 1
            fi
        fi
        return 0
    fi

    # Handle --pending (quick status check)
    if $pending; then
        local project_id=$(get_project_id)
        local project_param=""
        if [ -n "$project_id" ]; then
            project_param="?project=${project_id}"
        fi

        local result=$(curl -s "${INDEX_URL}/outline/pending${project_param}")

        # JSON output for agents/scripts
        if $json_output; then
            echo "$result" | jq .
            return 0
        fi

        local pending_count=$(echo "$result" | jq -r '.pending_count // 0')
        local up_to_date=$(echo "$result" | jq -r '.up_to_date_count // 0')
        local total=$(echo "$result" | jq -r '.total_files // 0')

        echo -e "${CYAN}${BOLD}⚡ aOa Outline Status${NC}"
        echo ""
        echo -e "  Pending:  ${YELLOW}${pending_count}${NC} need tags"
        echo -e "  Tagged:   ${GREEN}${up_to_date}${NC}"
        echo -e "  Total:    ${total}"

        if [ "$pending_count" -gt 0 ]; then
            echo ""
            echo -e "${DIM}In Claude Code, say: \"tag the codebase\"${NC}"
        else
            echo ""
            echo -e "${DIM}Search tags: aoa search \"#validation\"${NC}"
        fi
        return 0
    fi

    # Handle --enrich-all (batch mode - now "deep outline")
    if $enrich_all; then
        echo -e "${CYAN}${BOLD}⚡ aOa Outline - Deep Tagging${NC}"
        echo ""

        # Get current project context
        local project_id=$(get_project_id)
        local project_param=""
        if [ -n "$project_id" ]; then
            project_param="?project=${project_id}"
        fi

        # Get pending files from the service
        local result=$(curl -s "${INDEX_URL}/outline/pending${project_param}")

        local pending_count=$(echo "$result" | jq -r '.pending_count // 0')
        local up_to_date=$(echo "$result" | jq -r '.up_to_date_count // 0')
        local total=$(echo "$result" | jq -r '.total_files // 0')
        local ms=$(echo "$result" | jq -r '.ms // 0')

        printf "Scanned project in ${GREEN}%.1fms${NC}\n" "$ms"
        echo ""
        echo -e "  Total files:   ${BOLD}${total}${NC}"
        echo -e "  Tagged:        ${GREEN}${up_to_date}${NC}"
        echo -e "  Need tags:     ${YELLOW}${pending_count}${NC}"
        echo ""

        if [ "$pending_count" -eq 0 ]; then
            echo -e "${GREEN}All files are tagged!${NC}"
            echo ""
            echo -e "${DIM}Search: aoa search \"#validation\"${NC}"
            return 0
        fi

        echo -e "${BOLD}Files needing tags:${NC}"
        echo "$result" | jq -r '.pending[:10][] | "  \(.file) (\(.reason))"' 2>/dev/null

        if [ "$pending_count" -gt 10 ]; then
            echo -e "  ${DIM}... and $((pending_count - 10)) more${NC}"
        fi

        echo ""
        echo -e "${BOLD}To tag these files:${NC}"
        echo ""
        echo "  In Claude Code, say: \"tag the codebase\""
        echo ""
        return 0
    fi

    if [ -z "$file" ]; then
        echo "Usage: aoa outline <file>"
        echo "       aoa outline <file> --tags"
        echo "       aoa outline --pending"
        echo ""
        echo "Options:"
        echo "  --tags, -t    Show semantic tags for each symbol"
        echo "  --pending     Show files needing semantic tags"
        echo "  --enrich-all  Show detailed tagging status"
        echo "  --json, -j    Output as JSON"
        echo ""
        echo "To add semantic tags, say in Claude Code: \"tag the codebase\""
        echo ""
        echo "Examples:"
        echo "  aoa outline src/index.ts"
        echo "  aoa outline src/index.ts --tags"
        echo "  aoa outline --pending"
        return 1
    fi

    # Get current project context
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="&project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/outline?file=${file}${project_param}")

    # JSON output for agents/scripts
    if $json_output; then
        echo "$result" | jq .
        return 0
    fi

    # Check for errors
    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        local msg=$(echo "$result" | jq -r '.message // empty')
        [ -n "$msg" ] && echo -e "${DIM}${msg}${NC}"
        return 1
    fi

    local count=$(echo "$result" | jq -r '.count // 0')
    local ms=$(echo "$result" | jq -r '.ms // 0')
    local lang=$(echo "$result" | jq -r '.language // "unknown"')

    # Header
    if $enrich; then
        printf "${CYAN}${BOLD}⚡ %s symbols${NC} ${DIM}│${NC} ${GREEN}%.2fms${NC} ${DIM}│${NC} ${YELLOW}%s${NC} ${DIM}│${NC} ${BLUE}enrichment requested${NC}\n" "$count" "$ms" "$lang"
    elif $show_tags; then
        printf "${CYAN}${BOLD}⚡ %s symbols${NC} ${DIM}│${NC} ${GREEN}%.2fms${NC} ${DIM}│${NC} ${YELLOW}%s${NC} ${DIM}│${NC} ${CYAN}with tags${NC}\n" "$count" "$ms" "$lang"
    else
        printf "${CYAN}${BOLD}⚡ %s symbols${NC} ${DIM}│${NC} ${GREEN}%.2fms${NC} ${DIM}│${NC} ${YELLOW}%s${NC}\n" "$count" "$ms" "$lang"
    fi
    echo ""

    # Output symbols with line ranges (and tags if requested)
    if $show_tags; then
        # Fetch tags for this file from the inverted index
        local tags_json=$(curl -s "${INDEX_URL}/outline/tags?file=${file}${project_param}" 2>/dev/null)

        # Use jq to format output with tags inline
        echo "$result" | jq -r --argjson tags "$tags_json" '
            .symbols[] |
            .kind as $kind |
            .name as $name |
            .start_line as $start |
            .end_line as $end |
            ($tags.tags[$name] // []) | join(" ") as $sym_tags |
            if ($sym_tags | length) > 0 then
                "  \($kind) \($name) [\($start)-\($end)] \($sym_tags)"
            else
                "  \($kind) \($name) [\($start)-\($end)] (no tags)"
            end
        ' 2>/dev/null
    else
        echo "$result" | jq -r '.symbols[] | "  \(.kind) \(.name) [\(.start_line)-\(.end_line)]"' 2>/dev/null
    fi

    # If tagging requested, output instructions for Claude
    if $enrich; then
        echo ""
        echo -e "${BLUE}─── Semantic Tagging ───${NC}"
        echo ""
        echo -e "${DIM}To tag these symbols, Claude should:${NC}"
        echo -e "${DIM}1. Analyze the symbols above${NC}"
        echo -e "${DIM}2. Generate 2-5 semantic tags per symbol via Haiku${NC}"
        echo -e "${DIM}3. Store via: POST /outline/enriched with symbols array${NC}"
        echo ""
        # Output JSON for Claude to use
        echo "TAG_REQUEST:"
        echo "$result" | jq -c '{file: .file, language: .language, symbols: [.symbols[] | {name: .name, kind: .kind, line: .start_line, end_line: .end_line, signature: .signature}]}'
    fi
}

cmd_outline_status() {
    # Show outline tagging status
    local project_id=$(get_project_id)
    local project_param=""
    if [ -n "$project_id" ]; then
        project_param="?project=${project_id}"
    fi

    local result=$(curl -s "${INDEX_URL}/outline/pending${project_param}")
    local pending_count=$(echo "$result" | jq -r '.pending_count // 0')
    local up_to_date=$(echo "$result" | jq -r '.up_to_date_count // 0')
    local total=$(echo "$result" | jq -r '.total_files // 0')

    echo -e "${CYAN}${BOLD}⚡ aOa Outline${NC}"
    echo ""
    echo -e "  Pending:  ${YELLOW}${pending_count}${NC} files need semantic tags"
    echo -e "  Tagged:   ${GREEN}${up_to_date}${NC} files"
    echo -e "  Total:    ${total} files"
    echo ""

    if [ "$pending_count" -eq 0 ]; then
        echo -e "${GREEN}All files are tagged!${NC}"
        echo ""
        echo "Try: aoa search \"#authentication\" to find auth code"
        return 0
    fi

    echo -e "${BOLD}How to tag:${NC}"
    echo ""
    echo "  In Claude Code, say: \"tag the codebase\""
    echo ""
    echo "  Claude will:"
    echo "    1. Get pending files from /outline/pending"
    echo "    2. Batch files into groups of 15"
    echo "    3. Generate semantic tags per symbol via Haiku"
    echo "    4. Store tags for searchable access"
    echo ""
    echo -e "${DIM}Then search: aoa search \"#validation\" to find by tag${NC}"
}

# =============================================================================
# Knowledge Repo Commands
# =============================================================================

cmd_repo() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)
            cmd_repo_list "$@"
            ;;
        add)
            cmd_repo_add "$@"
            ;;
        remove|rm)
            cmd_repo_remove "$@"
            ;;
        *)
            # Assume it's a repo name - dispatch to repo-specific commands
            local repo_name="$subcmd"
            local repo_cmd="${1:-help}"
            shift || true

            case "$repo_cmd" in
                search|s)
                    cmd_repo_search "$repo_name" "$@"
                    ;;
                multi|m)
                    cmd_repo_multi "$repo_name" "$@"
                    ;;
                files|f)
                    cmd_repo_files "$repo_name" "$@"
                    ;;
                file)
                    cmd_repo_file "$repo_name" "$@"
                    ;;
                deps)
                    cmd_repo_deps "$repo_name" "$@"
                    ;;
                *)
                    echo -e "${BOLD}Repo: ${repo_name}${NC}"
                    echo ""
                    echo "Commands:"
                    echo "  aoa repo ${repo_name} search <term>   Search in ${repo_name}"
                    echo "  aoa repo ${repo_name} multi <t1,t2>  Multi-term search"
                    echo "  aoa repo ${repo_name} files [pat]    List files"
                    echo "  aoa repo ${repo_name} file <path>    Get file content"
                    echo "  aoa repo ${repo_name} deps <file>    Get dependencies"
                    ;;
            esac
            ;;
    esac
}

cmd_repo_list() {
    echo -e "${BOLD}Knowledge Repos${NC}"
    echo ""

    local result=$(curl -s "${INDEX_URL}/repos")
    local count=$(echo "$result" | jq '.repos | length')

    if [ "$count" == "0" ]; then
        echo -e "${DIM}No knowledge repos. Add one with:${NC}"
        echo "  aoa repo add <name> <git-url>"
        return
    fi

    echo "$result" | jq -r '.repos[] | "  \(.name): \(.files) files, \(.symbols) symbols"'
}

cmd_repo_add() {
    local name="$1"
    local url="$2"

    if [ -z "$name" ] || [ -z "$url" ]; then
        echo "Usage: aoa repo add <name> <git-url>"
        echo ""
        echo "Examples:"
        echo "  aoa repo add flask https://github.com/pallets/flask"
        echo "  aoa repo add react https://github.com/facebook/react"
        return 1
    fi

    echo -e "${DIM}Cloning and indexing ${name}...${NC}"

    local result=$(curl -s -X POST "${INDEX_URL}/repos" \
        -H "Content-Type: application/json" \
        -d "{\"name\": \"${name}\", \"url\": \"${url}\"}")

    local success=$(echo "$result" | jq -r '.success // false')

    if [ "$success" == "true" ]; then
        local msg=$(echo "$result" | jq -r '.message')
        echo -e "${GREEN}${msg}${NC}"
    else
        local err=$(echo "$result" | jq -r '.error // "Unknown error"')
        echo -e "${RED}Failed: ${err}${NC}"
        return 1
    fi
}

cmd_repo_remove() {
    local name="$1"

    if [ -z "$name" ]; then
        echo "Usage: aoa repo remove <name>"
        return 1
    fi

    echo -e "${DIM}Removing ${name}...${NC}"

    local result=$(curl -s -X DELETE "${INDEX_URL}/repos/${name}")

    local success=$(echo "$result" | jq -r '.success // false')

    if [ "$success" == "true" ]; then
        echo -e "${GREEN}Repo '${name}' removed${NC}"
    else
        local err=$(echo "$result" | jq -r '.error // "Unknown error"')
        echo -e "${RED}Failed: ${err}${NC}"
        return 1
    fi
}

cmd_repo_search() {
    local repo_name="$1"
    local query="$2"
    local mode="${3:-recent}"
    local limit="${4:-20}"

    if [ -z "$query" ]; then
        echo "Usage: aoa repo ${repo_name} search <term> [mode] [limit]"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/repo/${repo_name}/symbol?q=${query}&mode=${mode}&limit=${limit}")

    # Check for error
    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    local ms=$(echo "$result" | jq -r '.ms // 0')
    local count=$(echo "$result" | jq -r '.results | length')

    # Single punchy line with repo indicator
    printf "${CYAN}${BOLD}⚡ %s hits${NC} ${DIM}│${NC} ${GREEN}%.2fms${NC} ${DIM}│${NC} ${YELLOW}%s${NC}\n" "$count" "$ms" "$repo_name"

    echo "$result" | jq -r '.results[] | "  \(.file):\(.line)"' 2>/dev/null
}

cmd_repo_multi() {
    local repo_name="$1"
    local terms="$2"
    local mode="${3:-recent}"
    local limit="${4:-20}"

    if [ -z "$terms" ]; then
        echo "Usage: aoa repo ${repo_name} multi <term1,term2,...> [mode] [limit]"
        return 1
    fi

    local json_terms=$(echo "$terms" | tr ',' '\n' | jq -R . | jq -s .)

    local result=$(curl -s -X POST "${INDEX_URL}/repo/${repo_name}/multi" \
        -H "Content-Type: application/json" \
        -d "{\"terms\": ${json_terms}, \"mode\": \"${mode}\", \"limit\": ${limit}}")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    local ms=$(echo "$result" | jq -r '.ms // 0')

    echo -e "${DIM}Found in ${ms}ms (${repo_name}):${NC}"
    echo "$result" | jq -r '.results[] | "\(.file):\(.line)"' 2>/dev/null || echo "No results"
}

cmd_repo_files() {
    local repo_name="$1"
    local pattern="$2"
    local mode="${3:-recent}"
    local limit="${4:-30}"

    local url="${INDEX_URL}/repo/${repo_name}/files?mode=${mode}&limit=${limit}"
    [ -n "$pattern" ] && url="${url}&match=${pattern}"

    local result=$(curl -s "$url")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    echo "$result" | jq -r '.results[] | "\(.path) (\(.language))"'
}

cmd_repo_file() {
    local repo_name="$1"
    local path="$2"
    local lines="$3"

    if [ -z "$path" ]; then
        echo "Usage: aoa repo ${repo_name} file <path> [lines]"
        echo "  lines: e.g., 10-50"
        return 1
    fi

    local url="${INDEX_URL}/repo/${repo_name}/file?path=${path}"
    [ -n "$lines" ] && url="${url}&lines=${lines}"

    local result=$(curl -s "$url")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    echo "$result" | jq -r '.content'
}

cmd_repo_deps() {
    local repo_name="$1"
    local file="$2"
    local direction="${3:-outgoing}"

    if [ -z "$file" ]; then
        echo "Usage: aoa repo ${repo_name} deps <file> [outgoing|incoming]"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/repo/${repo_name}/deps?file=${file}&direction=${direction}")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    echo -e "${BOLD}${direction} dependencies for ${file}:${NC}"
    echo "$result" | jq -r '.dependencies[]' 2>/dev/null || echo "  (none)"
}

# =============================================================================
# Pattern Search (Agent-driven)
# =============================================================================

cmd_pattern() {
    # Usage: aoa pattern '{"func_def": "def\\s+\\w+"}' [--repo name] [--since 7d]
    local patterns="$1"
    shift || true

    local repo=""
    local since=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --repo|-r) repo="$2"; shift 2 ;;
            --since|-s) since="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    if [ -z "$patterns" ]; then
        echo "Usage: aoa pattern '<json patterns>' [--repo name] [--since time]"
        echo ""
        echo "Examples:"
        echo '  aoa pattern '\''{"func": "def\\s+\\w+\\("}'\'''
        echo '  aoa pattern '\''{"class": "class\\s+\\w+"}'\'' --repo flask'
        echo '  aoa pattern '\''{"error": "except\\s+\\w+"}'\'' --since 7d'
        return 1
    fi

    # Parse since time string
    local since_seconds=""
    if [ -n "$since" ]; then
        if [[ "$since" =~ ^([0-9]+)([smhd])$ ]]; then
            local num="${BASH_REMATCH[1]}"
            local unit="${BASH_REMATCH[2]}"
            case "$unit" in
                s) since_seconds=$num ;;
                m) since_seconds=$((num * 60)) ;;
                h) since_seconds=$((num * 3600)) ;;
                d) since_seconds=$((num * 86400)) ;;
            esac
        else
            since_seconds="$since"
        fi
    fi

    # Build request body
    local body="{\"patterns\": ${patterns}"
    [ -n "$repo" ] && body="${body}, \"repo\": \"${repo}\""
    [ -n "$since_seconds" ] && body="${body}, \"since\": ${since_seconds}"
    body="${body}}"

    local url="${INDEX_URL}/pattern"
    [ -n "$repo" ] && url="${INDEX_URL}/repo/${repo}/pattern"

    local result=$(curl -s -X POST "$url" \
        -H "Content-Type: application/json" \
        -d "$body")

    local err=$(echo "$result" | jq -r '.error // empty')
    if [ -n "$err" ]; then
        echo -e "${RED}${err}${NC}"
        return 1
    fi

    local ms=$(echo "$result" | jq -r '.stats.ms')
    local files=$(echo "$result" | jq -r '.stats.files_searched')
    local matched=$(echo "$result" | jq -r '.stats.files_matched')
    local idx=$(echo "$result" | jq -r '.index')

    echo -e "${DIM}Pattern search in ${idx}: ${files} files, ${matched} matched, ${ms}ms${NC}"
    echo ""

    # Output results grouped by pattern
    echo "$result" | jq -r '.results | to_entries[] | "\u001b[1m\(.key):\u001b[0m", (.value[] | "  \(.file):\(.line) \u001b[2m\(.context)\u001b[0m"), ""'
}

# =============================================================================
# Intent Commands
# =============================================================================

cmd_intent() {
    local subcmd="${1:-recent}"
    shift || true

    case "$subcmd" in
        recent|r)
            cmd_intent_recent "$@"
            ;;
        tags|t)
            cmd_intent_tags "$@"
            ;;
        files|f)
            cmd_intent_files "$@"
            ;;
        file)
            cmd_intent_file "$@"
            ;;
        stats)
            cmd_intent_stats "$@"
            ;;
        *)
            echo -e "${BOLD}Intent Tracking${NC}"
            echo ""
            echo "Commands:"
            echo "  aoa intent recent [since]   Recent intent records (e.g., 1h, 30m)"
            echo "  aoa intent tags             All tags with file counts"
            echo "  aoa intent files <tag>      Files associated with a tag"
            echo "  aoa intent file <path>      Tags associated with a file"
            echo "  aoa intent stats            Intent index statistics"
            ;;
    esac
}

cmd_intent_recent() {
    local limit="${1:-20}"
    local project_id=$(get_project_id)

    # Get metrics for header
    local metrics=$(curl -s "${INDEX_URL}/metrics?project_id=${project_id}")
    local tokens_saved=$(echo "$metrics" | jq -r '.savings.tokens // 0')
    local time_saved_sec=$(echo "$metrics" | jq -r '.savings.time_sec // 0')
    local hit_pct=$(echo "$metrics" | jq -r '.rolling.hit_at_5_pct // 0')
    local evaluated=$(echo "$metrics" | jq -r '.rolling.evaluated // 0')
    local hits=$(echo "$metrics" | jq -r '.rolling.hits // 0')

    # Get recent intent records
    local result=$(curl -s "${INDEX_URL}/intent/recent?limit=${limit}&project_id=${project_id}")
    local total=$(echo "$result" | jq -r '.stats.total_records // 0')

    # Format tokens with k suffix
    local tokens_k=$(awk "BEGIN {printf \"%.0f\", $tokens_saved/1000}")
    local hit_pct_int=$(printf "%.0f" "$hit_pct")

    # Calculate dynamic rate from rolling windows (5, 15, 30 min)
    local rate_data=$(python3 << 'PYEOF'
import json
import os
from pathlib import Path
from datetime import datetime, timedelta

home = os.path.expanduser('~')
projects_dir = Path(home) / '.claude' / 'projects'

if not projects_dir.exists():
    print(json.dumps({'rate_low': 2.0, 'rate_high': 5.0, 'samples': 0}))
    exit()

# Get recent session files
sessions = []
for project_dir in sorted(projects_dir.iterdir(), key=lambda p: p.stat().st_mtime, reverse=True)[:3]:
    sessions.extend(sorted(project_dir.glob('*.jsonl'), key=lambda p: p.stat().st_mtime, reverse=True)[:5])

now = datetime.now().astimezone()
windows = {'5min': [], '15min': [], '30min': []}

for session_file in sessions[:10]:
    try:
        messages = []
        with open(session_file, 'r') as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    event = json.loads(line)
                    if event.get('type') == 'assistant' and 'message' in event:
                        msg = event['message']
                        if 'usage' in msg and 'timestamp' in event:
                            ts = datetime.fromisoformat(event['timestamp'].replace('Z', '+00:00'))
                            tokens = msg['usage'].get('input_tokens', 0) + msg['usage'].get('output_tokens', 0)
                            messages.append({'ts': ts, 'tokens': tokens})
                except:
                    continue

        # Calculate rates between consecutive messages
        for i in range(1, len(messages)):
            try:
                duration_ms = (messages[i]['ts'] - messages[i-1]['ts']).total_seconds() * 1000
                tokens = messages[i]['tokens']
                age = (now - messages[i]['ts']).total_seconds() / 60  # minutes ago

                # Only include fast responses (< 15s) - pure LLM processing without tool delays
                # Filter: 100ms-15s duration, significant tokens, rate < 20ms/token
                if 100 < duration_ms < 15000 and tokens > 200:
                    rate = duration_ms / tokens
                    # Cap at 20ms/token - anything higher is tool/network overhead
                    if rate < 20:
                        if age <= 5:
                            windows['5min'].append(rate)
                        if age <= 15:
                            windows['15min'].append(rate)
                        if age <= 30:
                            windows['30min'].append(rate)
            except:
                continue
    except:
        continue

# Use P25 (faster end) since we're saving INPUT tokens which process faster
def percentile(lst, p):
    if not lst:
        return None
    s = sorted(lst)
    idx = int(len(s) * p / 100)
    return s[min(idx, len(s)-1)]

rates = []
for w in ['5min', '15min', '30min']:
    # P25 gives us the faster, cleaner samples
    p = percentile(windows[w], 25)
    if p is not None:
        rates.append(p)

if rates:
    rate_low = min(rates)
    rate_high = max(rates)
    samples = sum(len(v) for v in windows.values())
    print(json.dumps({'rate_low': round(rate_low, 2), 'rate_high': round(rate_high, 2), 'samples': samples}))
else:
    # Fallback: documented input processing rate (~2ms/token)
    print(json.dumps({'rate_low': 1.5, 'rate_high': 3.0, 'samples': 0}))
PYEOF
)

    local rate_low=$(echo "$rate_data" | jq -r '.rate_low')
    local rate_high=$(echo "$rate_data" | jq -r '.rate_high')
    local rate_samples=$(echo "$rate_data" | jq -r '.samples')

    # Calculate time range from dynamic rates
    local time_low=$(awk "BEGIN {printf \"%.0f\", $tokens_saved * $rate_low / 1000}")
    local time_high=$(awk "BEGIN {printf \"%.0f\", $tokens_saved * $rate_high / 1000}")

    # Format time range compactly
    format_time_compact() {
        local sec=$1
        if [ "$sec" -ge 3600 ] 2>/dev/null; then
            awk "BEGIN {printf \"%.1fh\", $sec / 3600}"
        elif [ "$sec" -ge 60 ] 2>/dev/null; then
            awk "BEGIN {printf \"%.0fm\", $sec / 60}"
        else
            echo "${sec}s"
        fi
    }

    local time_display=""
    if [ "$tokens_saved" -gt 0 ] 2>/dev/null && [ "$time_high" -gt 0 ] 2>/dev/null; then
        local t_low=$(format_time_compact $time_low)
        local t_high=$(format_time_compact $time_high)
        if [ "$t_low" = "$t_high" ]; then
            time_display="⚡~${t_low}"
        else
            time_display="⚡${t_low}-${t_high}"
        fi
    fi

    # Header
    echo -e "${CYAN}${BOLD}aOa Activity${NC}                                                 Session"
    echo ""
    # Only show savings if we have REAL data (not fabricated)
    if [ "$tokens_saved" -gt 0 ] 2>/dev/null; then
        if [ -n "$time_display" ]; then
            echo -e "${BOLD}SAVINGS${NC}         ${GREEN}↓${tokens_k}k tokens${NC} ${CYAN}${time_display}${NC} ${DIM}(rolling avg)${NC}"
        else
            echo -e "${BOLD}SAVINGS${NC}         ${GREEN}↓${tokens_k}k tokens${NC}"
        fi
    else
        echo -e "${BOLD}SAVINGS${NC}         ${DIM}(no measured savings yet)${NC}"
    fi
    echo -e "${BOLD}PREDICTIONS${NC}     ${hit_pct_int}% accuracy (${hits} of ${evaluated} hits)"
    echo -e "${BOLD}HOW IT WORKS${NC}    ${CYAN}aOa finds exact locations${NC}, so Claude reads only what it needs"
    echo -e "                ${DIM}Time: rolling avg (5/15/30min) of input token processing${NC}"
    echo ""
    echo -e "${DIM}─────────────────────────────────────────────────────────────────────────────────────────────${NC}"
    echo ""
    echo -e "ACTION     SOURCE   ATTRIB       aOa IMPACT                TAGS                                                    TARGET"

    # Process records - extract file_size (baseline) and output_size (actual)
    # Skip records with no files (noise) - require at least one real file
    echo "$result" | jq -r --arg project_root "$(get_project_root)" '.records[] |
        select(.files | length > 0) |
        select(.files[0] != null and .files[0] != "") |
        {
            tool: .tool,
            files: (.files[0] // "unknown"),
            file_count: (.files | length),
            tags: (.tags[0:6] | join(" ")),
            file_size: (if (.file_sizes and .files[0]) then .file_sizes[.files[0]] else null end),
            output_size: .output_size
        } |
        "\(.tool)|\(.files)|\(.tags)|\(.file_size // 0)|\(.output_size // 0)|\(.file_count)"
    ' 2>/dev/null | while IFS='|' read -r tool file tags file_size output_size file_count; do
        # Map tool to action and determine source
        local action="$tool"
        local source="Claude"

        case "$tool" in
            Bash)
                # Check for aOa commands - format: cmd:aoa:type:term:hits:time
                # Term may contain escaped colons (\:), so parse carefully
                if echo "$file" | grep -q "^cmd:aoa:"; then
                    action="Search"
                    source="aOa"
                    # Extract type (field 3)
                    local aoa_type=$(echo "$file" | cut -d: -f3)
                    # Extract hits:time from end (last 2 colon-separated fields)
                    local aoa_time=$(echo "$file" | rev | cut -d: -f1 | rev)
                    local aoa_hits=$(echo "$file" | rev | cut -d: -f2 | rev)
                    # Extract term: everything between field 3 and hits:time
                    # Remove "cmd:aoa:type:" prefix and ":hits:time" suffix
                    local aoa_term=$(echo "$file" | sed "s/^cmd:aoa:${aoa_type}://" | sed "s/:${aoa_hits}:${aoa_time}$//")
                    # Unescape colons in term
                    aoa_term=$(echo "$aoa_term" | sed 's/\\:/:/g')
                    # Store for later use in attribution/impact
                    export AOA_SEARCH_TYPE="$aoa_type"
                    export AOA_SEARCH_HITS="$aoa_hits"
                    export AOA_SEARCH_TIME="$aoa_time"
                    # Target is just the search term (truncate for display)
                    local display_term="${aoa_term:0:40}"
                    [ ${#aoa_term} -gt 40 ] && display_term="${display_term}..."
                    file="\"${display_term}\""
                # Old format: cmd:aoa search term (space separated)
                elif echo "$file" | grep -q "^cmd:aoa "; then
                    action="Search"
                    source="aOa"
                    local aoa_term=$(echo "$file" | sed 's/^cmd:aoa [a-z]* //')
                    export AOA_SEARCH_TYPE="search"
                    export AOA_SEARCH_HITS=""
                    export AOA_SEARCH_TIME=""
                    file="\"${aoa_term}\""
                fi
                ;;
            Outline)
                source="aOa"
                ;;
            HaikuTag|Intent)
                action="Intent"
                source="aOa"
                ;;
            Predict)
                source="aOa"
                ;;
        esac

        # Calculate tokens from file size if available
        local actual base saved time_saved base_tokens

        # If we have file size, use it for more accurate baseline
        if [ "$file_size" -gt 0 ] 2>/dev/null; then
            # BASE = file size in bytes / 4 (Claude uses ~4 chars per token)
            base_tokens=$((file_size / 4))

            # Format with k suffix if > 1000
            if [ $base_tokens -ge 1000 ]; then
                local base_k=$(awk "BEGIN {printf \"%.1f\", $base_tokens/1000}")
                base="${base_k}k"
            else
                base="$base_tokens"
            fi
        else
            # Fallback to defaults if no file size
            base_tokens=0
            base="?"
        fi

        # ACTUAL and SAVED - only show REAL metrics, never fabricate
        case "$action" in
            Grep|Glob)
                # Grep/Glob bypass aOa - warn user to use aoa search instead
                actual="SLOW"
                saved="SLOW"
                time_saved="SLOW"
                ;;
            Outline)
                # AI-generated symbol-level tags - enrichment, not reduction
                actual="AI"
                saved="AI"
                time_saved="-"
                ;;
            HaikuTag)
                # AI-generated tags - enrichment, not reduction
                actual="AI"
                saved="AI"
                time_saved="-"
                ;;
            *)
                # Check if we have REAL output_size data
                if [ "$output_size" -gt 0 ] 2>/dev/null; then
                    # REAL data: calculate actual tokens from output_size
                    local actual_tokens=$((output_size / 4))

                    # Format actual with k suffix if > 1000
                    if [ $actual_tokens -ge 1000 ]; then
                        local actual_k=$(awk "BEGIN {printf \"%.1f\", $actual_tokens/1000}")
                        actual="${actual_k}k"
                    else
                        actual="$actual_tokens"
                    fi

                    # Calculate savings if we have baseline
                    if [ $base_tokens -gt 0 ]; then
                        local saved_tokens=$((base_tokens - actual_tokens))
                        if [ $saved_tokens -gt 0 ]; then
                            if [ $saved_tokens -ge 1000 ]; then
                                local saved_k=$(awk "BEGIN {printf \"%.1f\", $saved_tokens/1000}")
                                saved="${saved_k}k"
                            else
                                saved="$saved_tokens"
                            fi
                        else
                            saved="0"
                        fi
                    else
                        saved="-"
                    fi
                    time_saved="-"
                else
                    # No output_size captured yet - be honest
                    actual="-"
                    saved="-"
                    time_saved="-"
                fi
                ;;
        esac

        # Format saved with k suffix if numeric and > 1000
        if [[ "$saved" =~ ^[0-9]+$ ]] && [ "$saved" -ge 1000 ]; then
            local saved_k=$(awk "BEGIN {printf \"%.1f\", $saved/1000}")
            saved="${saved_k}k"
        fi

        # Format file path (project-relative)
        local target=$(echo "$file" | sed "s|$(get_project_root)/||" 2>/dev/null || echo "$file")

        # Calculate attribution and impact
        local impact attribution

        # Special handling for aOa native operations - tell meaningful stories
        if [ "$action" = "Predict" ]; then
            # Extract confidence from tags (format: @XX%)
            local confidence=$(echo "$tags" | grep -oE '@[0-9]+%' | head -1 | tr -d '@')
            if [ -n "$confidence" ]; then
                attribution="${CYAN}${confidence}${NC} conf"
                # Remove confidence from tags to avoid duplication
                tags=$(echo "$tags" | sed 's/@[0-9]*%//' | sed 's/  / /g' | xargs)
            else
                attribution="${CYAN}predicted${NC}"
            fi
            # Show predicted file count
            if [ "$file_count" -gt 1 ] 2>/dev/null; then
                impact="${CYAN}${file_count} files${NC} suggested"
            else
                impact="${CYAN}1 file${NC} suggested"
            fi
        elif [ "$action" = "Intent" ]; then
            # Haiku semantic tagging
            attribution="${CYAN}semantic${NC}"
            local tag_count=$(echo "$tags" | wc -w)
            impact="${CYAN}${tag_count} tags${NC} generated"
        elif [ "$action" = "Outline" ]; then
            # Symbol-level enrichment
            attribution="${CYAN}symbols${NC}"
            impact="${CYAN}enriched${NC}"
        elif [ "$action" = "Search" ]; then
            # aOa search operations - show search type as attribution
            case "$AOA_SEARCH_TYPE" in
                pattern) attribution="${CYAN}pattern${NC}" ;;
                multi)   attribution="${CYAN}multi${NC}" ;;
                *)       attribution="${CYAN}symbol${NC}" ;;
            esac
            # Truncate time to 2 decimal places
            local time_display=$(printf "%.2f" "$AOA_SEARCH_TIME" 2>/dev/null || echo "$AOA_SEARCH_TIME")
            # Impact shows hits and timing
            if [ -n "$AOA_SEARCH_HITS" ] && [ "$AOA_SEARCH_HITS" != "0" ]; then
                impact="${CYAN}${BOLD}${AOA_SEARCH_HITS} hits${NC} ${DIM}│${NC} ${GREEN}${time_display}ms${NC}"
            else
                impact="${DIM}0 hits${NC}"
            fi
        # Determine attribution based on source and savings
        # aOa brand color is CYAN (consistent with status line)
        elif [ "$source" = "aOa" ]; then
            attribution="${CYAN}${BOLD}aOa${NC}"
        else
            attribution="-"  # Default, may be upgraded to "aOa guided" below
        fi

        if [ "$action" = "Predict" ] || [ "$action" = "Intent" ] || [ "$action" = "Outline" ] || [ "$action" = "Search" ]; then
            : # Impact already set above for aOa native operations
        elif [ "$saved" = "-" ]; then
            impact="-"
        elif [ "$saved" = "SLOW" ]; then
            # Glob/Grep warning - short to fit 25-char column
            impact="${YELLOW}⚠️ slow${NC} ${DIM}→ aoa search${NC}"
        elif [ "$saved" = "AI" ]; then
            if [ "$action" = "Outline" ]; then
                impact="${CYAN}symbol tags${NC}"
            else
                impact="${CYAN}semantic tags${NC}"
            fi
        else
            # Check if we have REAL savings data (both baseline AND actual output)
            if [ "$output_size" -gt 0 ] 2>/dev/null && [ "$base_tokens" -gt 0 ]; then
                # REAL measured savings - calculate percentage
                local actual_tokens=$((output_size / 4))
                local saved_tokens=$((base_tokens - actual_tokens))
                if [ $saved_tokens -gt 0 ]; then
                    local pct=$((saved_tokens * 100 / base_tokens))
                    # aOa-enabled: significant reduction means aOa guided Claude to read only what it needed
                    if [ $pct -ge 50 ]; then
                        # High savings = aOa guided (this is the value prop!)
                        # CYAN "aOa" (brand color) + GREEN "guided"
                        attribution="${CYAN}${BOLD}aOa${NC} ${GREEN}guided${NC}"
                        impact="${GREEN}${BOLD}↓${pct}%${NC} (${base} → ${actual})"
                    else
                        # Modest savings
                        impact="${GREEN}${pct}%${NC} (${base} → ${actual})"
                    fi
                else
                    # Full file read - standard Claude operation
                    impact="-"
                fi
            else
                # No measurement data - standard operation
                impact="-"
            fi
        fi

        # Truncate tags to 55 chars (room for 5-6 tags typically)
        if [ ${#tags} -gt 55 ]; then
            tags="${tags:0:52}..."
        fi

        # Color the source if it's aOa (brand consistency)
        local source_display
        if [ "$source" = "aOa" ]; then
            source_display="${CYAN}${BOLD}aOa${NC}"
        else
            source_display="$source"
        fi

        # Manual padding for color code compatibility
        # Strip ANSI codes to get visible length for source
        local source_visible=$(echo -e "$source_display" | sed 's/\x1b\[[0-9;]*m//g')
        local source_len=${#source_visible}
        local source_pad=$((8 - source_len))

        # Strip ANSI codes to get visible length for attribution
        local attrib_visible=$(echo -e "$attribution" | sed 's/\x1b\[[0-9;]*m//g')
        local attrib_len=${#attrib_visible}
        local attrib_pad=$((12 - attrib_len))

        # Strip ANSI codes for impact
        local impact_visible=$(echo -e "$impact" | sed 's/\x1b\[[0-9;]*m//g')
        local impact_len=${#impact_visible}
        # Emoji ⚠️ is 2 display cols but counts as 1 char - adjust
        [[ "$impact_visible" == *"⚠️"* ]] && impact_len=$((impact_len + 1))
        local impact_pad=$((25 - impact_len))

        printf "%-10s " "$action"
        echo -ne "$source_display"
        [ $source_pad -gt 0 ] && printf "%${source_pad}s" ""
        echo -ne " $attribution"
        [ $attrib_pad -gt 0 ] && printf "%${attrib_pad}s" ""
        echo -ne " $impact"
        [ $impact_pad -gt 0 ] && printf "%${impact_pad}s" ""
        printf " %-55s %s\n" "$tags" "$target"
    done

    echo ""
    echo -e "${DIM}─────────────────────────────────────────────────────────────────────────────────────────────${NC}"
    echo ""
    echo -e "${DIM}${limit} of ${total} operations.  Use: watch -n 2 aoa intent${NC}"
}

cmd_intent_tags() {
    local project_id=$(get_project_id)
    local result=$(curl -s "${INDEX_URL}/intent/tags?project_id=${project_id}")

    echo -e "${BOLD}Intent Tags${NC}"
    echo ""

    echo "$result" | jq -r '.tags[] | "  \(.tag) (\(.count) files)"' 2>/dev/null || echo "  (no tags yet)"
}

cmd_intent_files() {
    local tag="$1"
    local project_id=$(get_project_id)

    if [ -z "$tag" ]; then
        echo "Usage: aoa intent files <tag>"
        echo "Example: aoa intent files authentication"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/intent/files?tag=${tag}&project_id=${project_id}")

    local actual_tag=$(echo "$result" | jq -r '.tag')
    echo -e "${BOLD}Files for ${actual_tag}${NC}"
    echo ""

    echo "$result" | jq -r '.files[]' 2>/dev/null || echo "  (no files)"
}

cmd_intent_file() {
    local path="$1"
    local project_id=$(get_project_id)

    if [ -z "$path" ]; then
        echo "Usage: aoa intent file <path>"
        return 1
    fi

    local result=$(curl -s "${INDEX_URL}/intent/file?path=${path}&project_id=${project_id}")

    echo -e "${BOLD}Tags for ${path}${NC}"
    echo ""

    echo "$result" | jq -r '.tags[]' 2>/dev/null || echo "  (no tags)"
}

cmd_intent_stats() {
    local project_id=$(get_project_id)

    # Get metrics
    local metrics=$(curl -s "${INDEX_URL}/metrics?project_id=${project_id}")
    local hit_pct=$(echo "$metrics" | jq -r '.rolling.hit_at_5_pct // 0')
    local evaluated=$(echo "$metrics" | jq -r '.rolling.evaluated // 0')
    local hits=$(echo "$metrics" | jq -r '.rolling.hits // 0')
    local tokens_saved=$(echo "$metrics" | jq -r '.savings.tokens // 0')

    # Get intent stats
    local stats=$(curl -s "${INDEX_URL}/intent/stats?project_id=${project_id}")
    local total=$(echo "$stats" | jq -r '.total_records // 0')
    local unique_tags=$(echo "$stats" | jq -r '.unique_tags // 0')
    local unique_files=$(echo "$stats" | jq -r '.unique_files // 0')

    local hit_pct_int=$(printf "%.0f" "$hit_pct")

    # Header
    echo -e "${CYAN}${BOLD}aOa Session Statistics${NC}                                      ${total} operations"
    echo ""
    echo -e "${BOLD}WHAT WE TRACK (REAL DATA)${NC}"
    echo -e "  Predictions:      ${GREEN}${hit_pct_int}% accuracy${NC} (${hits} of ${evaluated} hits)"
    echo -e "  Operations:       ${total}"
    echo -e "  Unique files:     ${unique_files}"
    echo -e "  Unique tags:      ${unique_tags}"
    echo ""
    echo -e "${BOLD}TOKEN SAVINGS${NC}"
    if [ "$tokens_saved" -gt 0 ] 2>/dev/null; then
        local tokens_k=$(awk "BEGIN {printf \"%.1f\", $tokens_saved/1000}")
        echo -e "  Measured:         ${GREEN}↓${tokens_k}k tokens${NC}"
    else
        echo -e "  ${DIM}Not yet measured - requires capturing actual output tokens${NC}"
        echo -e "  ${DIM}Baseline (file sizes) is captured; actual output capture coming soon${NC}"
    fi
    echo ""
    echo -e "${DIM}─────────────────────────────────────────────────────────────────────────────────────────────${NC}"
    echo ""
    echo -e "${DIM}Run 'aoa intent' to see recent activity with per-operation details${NC}"
}

cmd_rate() {
    # Show token savings with estimated time savings
    # Uses conservative LLM processing rates based on documented performance

    echo -e "${CYAN}${BOLD}Time Savings Estimation${NC}"
    echo ""

    # Get current token savings from intent stats
    local project_id=$(get_project_id)
    local metrics=$(curl -s "${INDEX_URL}/metrics?project_id=${project_id}")
    local tokens_saved=$(echo "$metrics" | jq -r '.savings.tokens // 0')
    local tokens_k=$(awk "BEGIN {printf \"%.1f\", $tokens_saved/1000}")

    echo -e "${BOLD}YOUR TOKEN SAVINGS${NC}"
    if [ "$tokens_saved" -gt 0 ] 2>/dev/null; then
        echo -e "  Measured:         ${GREEN}↓${tokens_k}k tokens${NC}"
    else
        echo -e "  ${DIM}(no measured savings yet)${NC}"
    fi
    echo ""

    echo -e "${BOLD}TIME SAVINGS MODEL${NC}"
    echo -e "  ${DIM}LLMs process tokens at documented rates:${NC}"
    echo -e "    Input tokens:   ~100-500 tokens/second"
    echo -e "    Output tokens:  ~20-100 tokens/second"
    echo ""
    echo -e "  ${BOLD}Conservative estimate:${NC} 5-10ms per token (combined)"
    echo ""

    echo -e "${DIM}─────────────────────────────────────────────────────────────────────────────────────────────${NC}"
    echo ""

    if [ "$tokens_saved" -gt 0 ] 2>/dev/null; then
        # Calculate time savings range
        local time_low=$(awk "BEGIN {printf \"%.1f\", $tokens_saved * 5 / 1000}")   # 5ms/token
        local time_high=$(awk "BEGIN {printf \"%.1f\", $tokens_saved * 10 / 1000}") # 10ms/token

        echo -e "${BOLD}ESTIMATED TIME SAVINGS${NC}"
        echo -e "  Low estimate:     ${CYAN}~${time_low}s${NC} (at 5ms/token)"
        echo -e "  High estimate:    ${CYAN}~${time_high}s${NC} (at 10ms/token)"
        echo ""

        # Additional context for large savings
        if [ "$tokens_saved" -gt 100000 ]; then
            local mins_low=$(awk "BEGIN {printf \"%.1f\", $time_low / 60}")
            local mins_high=$(awk "BEGIN {printf \"%.1f\", $time_high / 60}")
            echo -e "  That's ${GREEN}${mins_low}-${mins_high} minutes${NC} of LLM processing avoided"
            echo ""
        fi

        echo -e "${DIM}Plus search speed: aOa search (~5ms) vs grep (~2-3 seconds)${NC}"
    else
        echo -e "${BOLD}EXAMPLE${NC}"
        echo -e "  If you save 22k tokens:"
        echo -e "    Low:  22k × 5ms  = ${CYAN}~110s${NC}"
        echo -e "    High: 22k × 10ms = ${CYAN}~220s${NC}"
    fi
    echo ""
    echo -e "${DIM}Note: Estimates based on typical Claude API processing speeds${NC}"
}

# =============================================================================
# Utility Commands
# =============================================================================

cmd_info() {
    echo -e "${CYAN}${BOLD}⚡ aOa Indexing Configuration${NC}"
    echo ""

    # Show aOa home
    echo -e "${BOLD}aOa Installation:${NC}"
    echo -e "  Home: ${AOA_HOME}"
    echo -e "  Data: ${AOA_DATA}"
    echo ""

    # Read from .env file if it exists (root directory, where docker-compose reads it)
    local env_file="${AOA_HOME}/.env"
    local projects_root="${HOME}"
    local gateway_port="8080"

    if [ -f "$env_file" ]; then
        projects_root=$(grep "^PROJECTS_ROOT=" "$env_file" 2>/dev/null | cut -d'=' -f2 || echo "$HOME")
        gateway_port=$(grep "^GATEWAY_PORT=" "$env_file" 2>/dev/null | cut -d'=' -f2 || echo "8080")
    fi

    # Show Docker configuration from .env
    echo -e "${BOLD}Docker Configuration:${NC} ${DIM}(from .env)${NC}"
    echo -e "  PROJECTS_ROOT:   ${projects_root} → /userhome"
    echo -e "  GATEWAY_PORT:    ${gateway_port}"
    echo -e "  Claude sessions: ${projects_root}/.claude ${DIM}(auto-derived)${NC}"
    echo ""
    echo -e "  ${DIM}Edit .env in aOa root to change, then restart Docker${NC}"
    echo ""

    # Show registered projects
    echo -e "${BOLD}Registered Projects:${NC}"
    local projects_file="${AOA_DATA}/projects.json"
    if [ -f "$projects_file" ] && [ "$(jq 'length' "$projects_file" 2>/dev/null)" != "0" ]; then
        jq -r '.[] | "  [\(.id | .[0:8])] \(.name) → \(.path)"' "$projects_file" 2>/dev/null
    else
        echo -e "  ${DIM}(none - run 'aoa init' in a project)${NC}"
    fi
    echo ""

    # Show current project context
    local project_root=$(get_project_root)
    local project_id=$(get_project_id)
    if [ -n "$project_root" ]; then
        echo -e "${BOLD}Current Project:${NC}"
        echo -e "  Root: ${project_root}"
        echo -e "  ID:   ${project_id:-not initialized}"

        # Check if initialized
        if [ -z "$project_id" ]; then
            echo -e "  ${YELLOW}→ Run 'aoa init' to enable aOa for this project${NC}"
        fi
    else
        echo -e "${BOLD}Current Project:${NC}"
        echo -e "  ${DIM}Not in a git repository${NC}"
    fi
    echo ""

    # Show what gets indexed
    echo -e "${BOLD}What Gets Indexed:${NC}"
    echo -e "  ✓ Files in registered project roots"
    echo -e "  ✓ Knowledge repos (repos/ directory)"
    echo -e "  ✓ Claude session history (~/.claude)"
    echo ""
    echo -e "${BOLD}What Is Skipped:${NC}"
    echo -e "  ✗ node_modules, .git, __pycache__, dist, build, etc."
    echo -e "  ✗ Files outside registered projects"
    echo -e "  ✗ Unrecognized file extensions"
    echo ""
    echo -e "${DIM}See: .aoa/config.json for full configuration${NC}"
}

cmd_services() {
    echo -e "${CYAN}${BOLD}"
    cat << 'EOF'
╔══════════════════════════════════════════════════════════════════════╗
║                         aOa Attack Map                               ║
╠══════════════════════════════════════════════════════════════════════╣
║                                                                      ║
║  ┌─────────────────────────────────────────────────────────────┐    ║
║  │                     GATEWAY (:8080)                         │    ║
║  │              Single entry point for all angles              │    ║
║  └─────────────────────────────────────────────────────────────┘    ║
║                              │                                       ║
║          ┌───────────────────┼───────────────────┐                  ║
║          ▼                   ▼                   ▼                  ║
║  ┌───────────────┐   ┌───────────────┐   ┌───────────────┐         ║
║  │    INDEX      │   │    STATUS     │   │   GIT-PROXY   │         ║
║  │    :9999      │   │    :9998      │   │    :9997      │         ║
║  │               │   │               │   │               │         ║
║  │ • Symbol      │   │ • Sessions    │   │ • Clone repos │         ║
║  │ • Ranking     │   │ • History     │   │ • Allowlist   │         ║
║  │ • Intent      │   │ • Metrics     │   │               │         ║
║  │ • Memory      │   │               │   │               │         ║
║  │ • Tuner       │   │               │   │               │         ║
║  └───────────────┘   └───────────────┘   └───────────────┘         ║
║          │                                                          ║
║          ▼                                                          ║
║  ┌───────────────┐                                                  ║
║  │    REDIS      │                                                  ║
║  │    :6379      │                                                  ║
║  │               │                                                  ║
║  │ • Scores      │                                                  ║
║  │ • Transitions │                                                  ║
║  │ • Predictions │                                                  ║
║  └───────────────┘                                                  ║
║                                                                      ║
╠══════════════════════════════════════════════════════════════════════╣
║  THE FIVE ANGLES                                                     ║
╠══════════════════════════════════════════════════════════════════════╣
║                                                                      ║
║  ⚡ SYMBOL         O(1) symbol lookup across codebase                ║
║     aoa search <term>                                                ║
║                                                                      ║
║  🎯 INTENT         Track tool calls, extract behavior patterns       ║
║     aoa intent recent                                                ║
║                                                                      ║
║  🧠 STRIKE         Predictive context, dynamic working memory        ║
║     aoa context "fix auth bug"                                       ║
║                                                                      ║
║  📊 SIGNAL         Multi-term ranking, pattern matching              ║
║     aoa multi auth,session                                           ║
║                                                                      ║
║  📁 INTEL          External reference repos, isolated search         ║
║     aoa repo <name> search <term>                                    ║
║                                                                      ║
╚══════════════════════════════════════════════════════════════════════╝
EOF
    echo -e "${NC}"

    # Show live stats
    echo -e "${BOLD}Live Status${NC}"
    echo ""

    # Health check
    local index_ok=false
    local status_ok=false
    local redis_ok=false

    curl -s --connect-timeout 1 "http://localhost:8080/health" > /dev/null 2>&1 && index_ok=true
    curl -s --connect-timeout 1 "http://localhost:8080/status" > /dev/null 2>&1 && status_ok=true

    # Check Redis (works in both unified and compose modes)
    if docker exec aoa redis-cli ping > /dev/null 2>&1; then
        redis_ok=true
    elif docker exec aoa-redis-1 redis-cli ping > /dev/null 2>&1; then
        redis_ok=true
    fi

    if $index_ok; then
        echo -e "  Index:  ${GREEN}✓${NC} Running"
    else
        echo -e "  Index:  ${RED}✗${NC} Not responding"
    fi

    if $status_ok; then
        echo -e "  Status: ${GREEN}✓${NC} Running"
    else
        echo -e "  Status: ${RED}✗${NC} Not responding"
    fi

    if $redis_ok; then
        echo -e "  Redis:  ${GREEN}✓${NC} Connected"
    else
        echo -e "  Redis:  ${RED}✗${NC} Not connected"
    fi

    echo ""

    # Quick stats
    local memory_result=$(curl -s "http://localhost:8080/memory?format=compact" 2>/dev/null)
    if [ -n "$memory_result" ]; then
        local files=$(echo "$memory_result" | jq -r '.files_analyzed' 2>/dev/null)
        local ms=$(echo "$memory_result" | jq -r '.ms' 2>/dev/null)
        echo -e "  Memory: ${files} active files, ${GREEN}${ms}ms${NC} latency"
    fi

    local health_result=$(curl -s "http://localhost:8080/health" 2>/dev/null)
    if [ -n "$health_result" ]; then
        local symbols=$(echo "$health_result" | jq -r '.local.symbols' 2>/dev/null)
        local idx_files=$(echo "$health_result" | jq -r '.local.files' 2>/dev/null)
        echo -e "  Index:  ${idx_files} files, ${symbols} symbols"
    fi
}

cmd_memory() {
    local format="${1:-prose}"

    case "$format" in
        -c|--compact|compact)
            format="compact"
            ;;
        -s|--structured|structured|json)
            format="structured"
            ;;
        -p|--prose|prose|*)
            format="prose"
            ;;
    esac

    local result=$(curl -s "http://localhost:8080/memory?format=${format}")

    if [ "$format" = "structured" ]; then
        echo "$result" | jq .
    else
        local memory=$(echo "$result" | jq -r '.memory')
        local ms=$(echo "$result" | jq -r '.ms')
        local files=$(echo "$result" | jq -r '.files_analyzed')

        echo -e "${CYAN}${BOLD}⚡ aOa Working Memory${NC} ${DIM}│${NC} ${files} files ${DIM}│${NC} ${GREEN}${ms}ms${NC}"
        echo ""
        echo "$memory"
    fi
}

cmd_health() {
    local project_root=$(get_project_root)
    local all_ok=true
    local warnings=0

    echo -e "${BOLD}aOa Health Check${NC}"
    echo -e "────────────────────────────────────────"
    echo ""

    # =========================================================================
    # SERVICES
    # =========================================================================
    echo -e "${BOLD}Services${NC}"

    # Check Docker
    echo -n "  Docker:        "
    if docker ps --filter "name=aoa" --format "{{.Names}}" 2>/dev/null | grep -q "aoa"; then
        echo -e "${GREEN}✓${NC} Container running"
    else
        echo -e "${RED}✗${NC} Container not found"
        all_ok=false
    fi

    # Check Index service
    echo -n "  Index:         "
    local idx_health=""
    if curl -s --connect-timeout 2 "${INDEX_URL}/health" > /dev/null 2>&1; then
        idx_health=$(curl -s "${INDEX_URL}/health")
        local mode=$(echo "$idx_health" | jq -r '.mode // "legacy"')
        if [ "$mode" = "global" ]; then
            local project_count=$(echo "$idx_health" | jq '.projects | length // 0')
            echo -e "${GREEN}✓${NC} Running (${project_count} project(s))"
        else
            local local_files=$(echo "$idx_health" | jq -r '.local.files // 0')
            local local_symbols=$(echo "$idx_health" | jq -r '.local.symbols // 0')
            echo -e "${GREEN}✓${NC} ${local_files} files, ${local_symbols} symbols"
        fi
    else
        echo -e "${RED}✗${NC} Not responding"
        all_ok=false
    fi

    # Check Redis
    echo -n "  Redis:         "
    if docker exec aoa redis-cli ping > /dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} Connected"
    elif docker exec aoa-redis-1 redis-cli ping > /dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} Connected"
    else
        echo -e "${YELLOW}!${NC} Not connected ${DIM}(predictions disabled)${NC}"
        warnings=$((warnings + 1))
    fi

    echo ""

    # =========================================================================
    # PROJECT CONFIGURATION
    # =========================================================================
    echo -e "${BOLD}Project Configuration${NC}"

    # Check if initialized
    echo -n "  Initialized:   "
    if [ -f "$project_root/.aoa/home.json" ]; then
        local project_id=$(jq -r '.project_id // "none"' "$project_root/.aoa/home.json" 2>/dev/null)
        echo -e "${GREEN}✓${NC} ${DIM}${project_id:0:8}...${NC}"
    else
        echo -e "${RED}✗${NC} Not initialized ${DIM}(run 'aoa init')${NC}"
        all_ok=false
    fi

    # Check hooks (essential: intent-capture + status-line)
    echo -n "  Hooks:         "
    local hook_count=0
    [ -f "$project_root/.claude/hooks/aoa-intent-capture.py" ] && hook_count=$((hook_count + 1))
    [ -f "$project_root/.claude/hooks/aoa-status-line.sh" ] && hook_count=$((hook_count + 1))

    if [ "$hook_count" -eq 2 ]; then
        echo -e "${GREEN}✓${NC} Essential hooks installed"
    elif [ "$hook_count" -gt 0 ]; then
        echo -e "${YELLOW}!${NC} ${hook_count}/2 essential hooks ${DIM}(partial)${NC}"
        warnings=$((warnings + 1))
    else
        echo -e "${RED}✗${NC} No hooks found"
        all_ok=false
    fi

    # Check CLAUDE.md
    echo -n "  CLAUDE.md:     "
    if [ -f "$project_root/CLAUDE.md" ]; then
        if grep -q "aoa search" "$project_root/CLAUDE.md" 2>/dev/null; then
            echo -e "${GREEN}✓${NC} Present with aOa instructions"
        else
            echo -e "${YELLOW}!${NC} Present ${DIM}(missing aOa instructions)${NC}"
            warnings=$((warnings + 1))
        fi
    else
        echo -e "${YELLOW}!${NC} Not found ${DIM}(optional)${NC}"
        warnings=$((warnings + 1))
    fi

    echo ""

    # =========================================================================
    # FUNCTIONALITY
    # =========================================================================
    echo -e "${BOLD}Functionality${NC}"

    # Test search
    echo -n "  Search:        "
    local search_result=$(curl -s --connect-timeout 2 "${INDEX_URL}/symbol?q=test" 2>/dev/null)
    if [ -n "$search_result" ]; then
        local ms=$(echo "$search_result" | jq -r '.ms // "?"')
        echo -e "${GREEN}✓${NC} Working ${DIM}(${ms}ms)${NC}"
    else
        echo -e "${RED}✗${NC} Not working"
        all_ok=false
    fi

    # Check intent capture
    echo -n "  Intent:        "
    local intent_result=$(curl -s --connect-timeout 2 "${INDEX_URL}/intent/recent?limit=1" 2>/dev/null)
    if [ -n "$intent_result" ]; then
        local total=$(echo "$intent_result" | jq -r '.stats.total_records // 0')
        local tags=$(echo "$intent_result" | jq -r '.stats.unique_tags // 0')
        echo -e "${GREEN}✓${NC} ${total} recorded, ${tags} tags"
    else
        echo -e "${YELLOW}!${NC} No data ${DIM}(fresh install)${NC}"
        warnings=$((warnings + 1))
    fi

    # Check semantic compression (outline angle)
    echo -n "  Outline:       "
    if docker exec aoa python3 -c "import tree_sitter" > /dev/null 2>&1 || \
       docker exec aoa-index-1 python3 -c "import tree_sitter" > /dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} Semantic compression ready"
    else
        echo -e "${YELLOW}!${NC} Semantic compression unavailable"
        warnings=$((warnings + 1))
    fi

    echo ""

    # =========================================================================
    # SUMMARY
    # =========================================================================
    echo -e "────────────────────────────────────────"
    if $all_ok && [ "$warnings" -eq 0 ]; then
        echo -e "Status: ${GREEN}✓ All systems operational${NC}"
    elif $all_ok; then
        echo -e "Status: ${YELLOW}! Operational with ${warnings} warning(s)${NC}"
    else
        echo -e "Status: ${RED}✗ Issues detected${NC}"
        echo -e "${DIM}Run 'aoa init' to configure this project${NC}"
    fi
}

cmd_baseline() {
    echo -e "${BOLD}aOa Baseline Costs${NC}"
    echo -e "${DIM}Subagent activity tracked from session logs${NC}"
    echo

    local result=$(curl -s "${STATUS_URL}/baseline" 2>/dev/null)

    if [ -z "$result" ]; then
        echo -e "${RED}Could not connect to status service${NC}"
        return 1
    fi

    local total_tokens=$(echo "$result" | jq -r '.baseline.total_tokens // 0')
    local tool_calls=$(echo "$result" | jq -r '.baseline.tool_calls // 0')
    local search_tools=$(echo "$result" | jq -r '.baseline.search_tools // 0')
    local potential_savings=$(echo "$result" | jq -r '.baseline.potential_savings_tokens // 0')
    local last_sync=$(echo "$result" | jq -r '.baseline.last_sync // 0')

    if [ "$total_tokens" -eq 0 ]; then
        echo -e "${DIM}No baseline data yet.${NC}"
        echo -e "${DIM}Subagent sync runs automatically in the background.${NC}"
        return 0
    fi

    # Format tokens
    format_k() {
        local n=$1
        if [ "$n" -ge 1000 ]; then
            echo "$((n / 1000))k"
        else
            echo "$n"
        fi
    }

    local tokens_fmt=$(format_k $total_tokens)
    local savings_fmt=$(format_k $potential_savings)

    echo -e "  ${BOLD}Subagent Activity Observed:${NC}"
    echo -e "    Tool calls: ${CYAN}${tool_calls}${NC}"
    echo -e "    Tokens: ${CYAN}${tokens_fmt}${NC}"
    echo -e "    Grep/Glob used: ${YELLOW}${search_tools}${NC} times"
    echo

    if [ "$potential_savings" -gt 0 ]; then
        local pct=$((potential_savings * 100 / total_tokens))
        echo -e "  ${BOLD}Potential Savings with aOa:${NC}"
        echo -e "    Tokens: ${GREEN}↓${savings_fmt}${NC} ${DIM}(~${pct}% of subagent tokens)${NC}"
        echo -e "    Tool calls: ${GREEN}↓${search_tools}${NC} ${DIM}Grep/Glob → aoa search${NC}"
        echo
    fi

    if [ "$last_sync" -gt 0 ]; then
        local now=$(date +%s)
        local age=$((now - last_sync))
        echo -e "  ${DIM}Last sync: ${age}s ago${NC}"
    fi
    echo
}

cmd_metrics() {
    local project_id=$(get_project_id)
    local metrics=$(curl -s --connect-timeout 2 "${INDEX_URL}/metrics?project_id=${project_id}" 2>/dev/null)

    if [ -z "$metrics" ] || echo "$metrics" | jq -e '.error' > /dev/null 2>&1; then
        echo -e "${RED}Metrics not available${NC}"
        return 1
    fi

    # Parse metrics
    local hit_pct=$(echo "$metrics" | jq -r '.rolling.hit_at_5_pct // 0')
    local evaluated=$(echo "$metrics" | jq -r '.rolling.evaluated // 0')
    local hits=$(echo "$metrics" | jq -r '.rolling.hits // 0')
    local tokens_saved=$(echo "$metrics" | jq -r '.savings.tokens // 0')
    local time_saved=$(echo "$metrics" | jq -r '.savings.time_sec // 0')
    local trend=$(echo "$metrics" | jq -r '.trend // "unknown"')

    # Format hit percentage
    local hit_int=$(printf "%.0f" "$hit_pct")

    # Traffic light
    local color=$GREEN
    local light="🟢"
    if [ "$evaluated" -lt 3 ]; then
        color=$DIM
        light="⚪"
    elif [ "$hit_int" -lt 80 ]; then
        color=$YELLOW
        light="🟡"
    fi

    echo -e "${BOLD}aOa Prediction Metrics${NC}"
    echo ""
    echo -e "  Accuracy:     ${color}${light} ${hit_int}%${NC} ${DIM}(${evaluated} evaluated)${NC}"
    echo -e "  Hits:         ${hits}"
    echo -e "  Trend:        ${trend}"
    echo ""
    echo -e "${BOLD}Savings${NC}"
    echo -e "  Tokens:       ${GREEN}↓${tokens_saved}${NC}"
    echo -e "  Time:         ${GREEN}⚡${time_saved}s${NC}"
    echo ""
    echo -e "${DIM}Full JSON: aoa metrics --json${NC}"

    # Handle --json flag
    if [[ "${1:-}" == "--json" ]] || [[ "${1:-}" == "-j" ]]; then
        echo ""
        echo "$metrics" | jq .
    fi
}

cmd_history() {
    local limit="${1:-20}"

    curl -s "${STATUS_URL}/history?limit=${limit}" | jq -r '.events[] |
        if .type == "request" then
            "[\(.ts | strftime("%H:%M:%S"))] \(.model) in:\(.input) out:\(.output) $\(.cost)"
        elif .type == "model_switch" then
            "[\(.ts | strftime("%H:%M:%S"))] -> \(.model)"
        elif .type == "block" then
            "[\(.ts | strftime("%H:%M:%S"))] BLOCKED \(.block_type)"
        else
            "[\(.ts | strftime("%H:%M:%S"))] \(.type)"
        end
    '
}

cmd_reset() {
    local target="${1:-session}"

    case "$target" in
        session)
            curl -s -X POST "${STATUS_URL}/session/reset" | jq .
            echo -e "${GREEN}Session reset${NC}"
            ;;
        weekly)
            curl -s -X POST "${STATUS_URL}/weekly/reset" | jq .
            echo -e "${GREEN}Weekly stats reset${NC}"
            ;;
        *)
            echo "Usage: aoa reset [session|weekly]"
            return 1
            ;;
    esac
}

cmd_whitelist() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)
            curl -s "${INDEX_URL}/git/whitelist" | jq -r '
                "Default hosts:", (.default_hosts[] | "  \(.)"),
                "", "Custom hosts:",
                (if .custom_hosts | length > 0 then (.custom_hosts[] | "  \(.)") else "  (none)" end)
            '
            ;;
        add)
            local host="$1"
            if [ -z "$host" ]; then
                echo "Usage: aoa whitelist add <host>"
                echo "Example: aoa whitelist add git.company.com"
                return 1
            fi
            curl -s -X POST "${INDEX_URL}/git/whitelist" \
                -H "Content-Type: application/json" \
                -d "{\"host\": \"${host}\"}" | jq .
            ;;
        remove|rm)
            local host="$1"
            if [ -z "$host" ]; then
                echo "Usage: aoa whitelist remove <host>"
                return 1
            fi
            curl -s -X DELETE "${INDEX_URL}/git/whitelist/${host}" | jq .
            ;;
        *)
            echo -e "${BOLD}Whitelist Management${NC}"
            echo ""
            echo "Commands:"
            echo "  aoa whitelist list         Show allowed URLs"
            echo "  aoa whitelist add <host>   Add URL to whitelist"
            echo "  aoa whitelist remove <h>   Remove URL from whitelist"
            echo ""
            echo "Examples:"
            echo "  aoa whitelist add git.company.com"
            echo "  aoa whitelist add docs.internal.org"
            ;;
    esac
}

cmd_help() {
    cat << 'EOF'
                              AOA
                       5 angles. 1 attack.

GETTING STARTED
  ./install.sh           Install aOa globally (once)
  aoa init               Enable aOa in current project
  aoa remove             Disable aOa in current project
  aoa projects           List all enabled projects

PROJECT SEARCH
  search <term>          O(1) symbol lookup (current project)
  multi <t1,t2,...>      Multi-angle search
  changes [time]         Recent file changes (e.g., 5m, 1h)
  files [pattern]        List indexed files

OUTLINE ANGLE (code structure + semantic tags)
  outline <file>         Code structure (functions, classes, methods)
  outline --pending      Check tagging status (pending/tagged)
  outline --enrich-all   Show files needing tags (detailed)

  To add semantic tags: In Claude Code, say "tag the codebase"
  Then search: aoa search "#authentication"

SESSION
  history [limit]        Recent events
  reset [session|weekly] Reset counters

SIGNAL ANGLE (pattern matching)
  pattern '<json>'       Multi-pattern regex search
    --repo <name>        Search in specific repo
    --since <time>       Only files modified recently (e.g., 7d)

INTENT ANGLE (behavioral tracking)
  intent recent [since]  Recent intent records (e.g., 1h, 30m)
  intent tags            All tags with file counts
  intent files <tag>     Files associated with an intent tag
  intent file <path>     Tags associated with a file
  intent stats           Intent index statistics

INTEL ANGLE (external reference)
  repo list              List intel sources
  repo add <name> <url>  Clone and index a git repo
  repo remove <name>     Remove an intel source
  repo <name> search <t> Search in a specific repo

SYSTEM
  health                 Check all angles
  info                   Show indexing config, mounts, registered projects
  metrics                Prediction accuracy and savings
  baseline               Subagent baseline costs and potential savings
  services               Visual service map with live status

EXAMPLES
  # First time setup
  ./install.sh                  # Install globally (once)
  cd ~/my-project && aoa init   # Enable for project

  # Search your project
  aoa search handleAuth
  aoa multi auth,session,token

  # Add reference repos
  aoa repo add flask https://github.com/pallets/flask
  aoa repo flask search Blueprint

ARCHITECTURE
  ~/.aoa/                Global installation
  .claude/hooks/         Per-project hooks (created by aoa init)

  Install once → enable per-project → search anywhere

EOF
}

# =============================================================================
# Main
# =============================================================================

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        # Project Management (new in v2)
        init)       cmd_init "$@" ;;
        remove|rm)  cmd_remove "$@" ;;
        projects)   cmd_projects "$@" ;;

        # Session
        history|h)  cmd_history "$@" ;;
        reset)      cmd_reset "$@" ;;

        # Local Index
        search)     cmd_search "$@" ;;
        multi|m)    cmd_multi "$@" ;;
        changes|c)  cmd_changes "$@" ;;
        files|f)    cmd_files "$@" ;;
        outline|o)  cmd_outline "$@" ;;
        enrich|e)   cmd_outline --pending ;;  # Alias - now part of outline

        # Pattern Search
        pattern|p)  cmd_pattern "$@" ;;

        # Intent Tracking
        intent|i)   cmd_intent "$@" ;;

        # Whitelist Management
        whitelist|w) cmd_whitelist "$@" ;;

        # Knowledge Repos
        repo|r)     cmd_repo "$@" ;;

        # System
        health)     cmd_health ;;
        metrics)    cmd_metrics ;;
        rate)       cmd_rate ;;
        baseline|bl) cmd_baseline ;;
        memory|mem) cmd_memory "$@" ;;
        services|svc|map) cmd_services ;;
        info)       cmd_info ;;
        help|--help|-h) cmd_help ;;

        *)
            echo -e "${RED}Unknown command: $cmd${NC}"
            echo "Run 'aoa help' for usage"
            return 1
            ;;
    esac
}

main "$@"
